"function_name","definition","return_type","arguments"
"xdelo_audit_forward_changes","CREATE OR REPLACE FUNCTION public.xdelo_audit_forward_changes()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.is_forward AND OLD.is_forward IS DISTINCT FROM NEW.is_forward THEN
        INSERT INTO unified_audit_logs (
            event_type,
            entity_id,
            telegram_message_id,
            chat_id,
            previous_state,
            new_state,
            metadata,
            correlation_id
        ) VALUES (
            'forward_status_changed'::audit_event_type,
            NEW.id,
            NEW.telegram_message_id,
            NEW.chat_id,
            jsonb_build_object('is_forward', OLD.is_forward),
            jsonb_build_object('is_forward', NEW.is_forward),
            jsonb_build_object(
                'original_message_id', NEW.original_message_id,
                'forward_count', NEW.forward_count
            ),
            NEW.correlation_id
        );
    END IF;
    RETURN NULL;
END;
$function$
","trigger",""
"xdelo_check_media_group_content","CREATE OR REPLACE FUNCTION public.xdelo_check_media_group_content(p_media_group_id text, p_message_id uuid, p_correlation_id text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_source_message record;
  v_target_message record;
  v_lock_acquired BOOLEAN;
BEGIN
  -- Skip if no media group ID
  IF p_media_group_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'no_media_group_id'
    );
  END IF;

  -- Try to acquire an advisory lock on the media group ID
  -- This prevents multiple concurrent attempts to sync the same media group
  v_lock_acquired := pg_try_advisory_xact_lock(hashtext(p_media_group_id));
  
  IF NOT v_lock_acquired THEN
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'media_group_lock_not_acquired',
      'message', 'Another process is currently syncing this media group'
    );
  END IF;

  -- Get the target message details
  SELECT 
    id, 
    analyzed_content, 
    is_original_caption,
    group_caption_synced
  INTO v_target_message
  FROM messages
  WHERE id = p_message_id;
  
  -- If message already has content, skip
  IF v_target_message.analyzed_content IS NOT NULL THEN
    RETURN jsonb_build_object(
      'success', true,
      'reason', 'already_has_content',
      'message_id', p_message_id
    );
  END IF;
  
  -- Find a source message in the same group with analyzed content
  SELECT 
    id, 
    analyzed_content, 
    is_original_caption
  INTO v_source_message
  FROM messages
  WHERE 
    media_group_id = p_media_group_id
    AND id != p_message_id
    AND analyzed_content IS NOT NULL
    AND processing_state = 'completed'
  ORDER BY 
    is_original_caption DESC,
    created_at ASC
  LIMIT 1;
  
  -- If no source message found, return with no action
  IF v_source_message.id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'reason', 'no_analyzed_content_in_group'
    );
  END IF;
  
  -- Update the target message with data from source message
  UPDATE messages
  SET 
    analyzed_content = v_source_message.analyzed_content,
    message_caption_id = v_source_message.id,
    is_original_caption = false,
    group_caption_synced = true,
    processing_state = 'completed',
    processing_completed_at = NOW()
  WHERE id = p_message_id;
  
  -- Log the sync event
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    correlation_id,
    metadata,
    event_timestamp
  ) VALUES (
    'media_group_content_synced',
    p_message_id,
    p_correlation_id,
    jsonb_build_object(
      'media_group_id', p_media_group_id,
      'source_message_id', v_source_message.id,
      'method', 'db_check'
    ),
    NOW()
  );
  
  -- Return success
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Synced content from media group',
    'source_message_id', v_source_message.id,
    'is_original_source', v_source_message.is_original_caption
  );
EXCEPTION WHEN OTHERS THEN
  -- Log error
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    correlation_id,
    error_message,
    metadata,
    event_timestamp
  ) VALUES (
    'media_group_sync_error',
    p_message_id,
    p_correlation_id,
    SQLERRM,
    jsonb_build_object(
      'media_group_id', p_media_group_id,
      'error_detail', SQLSTATE
    ),
    NOW()
  );
  
  RETURN jsonb_build_object(
    'success', false,
    'error', SQLERRM,
    'reason', 'error_during_sync'
  );
END;
$function$
","jsonb","p_media_group_id text, p_message_id uuid, p_correlation_id text DEFAULT NULL::text"
"xdelo_check_media_group_on_message_change","CREATE OR REPLACE FUNCTION public.xdelo_check_media_group_on_message_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only proceed for messages in a media group that don't have a caption
  -- and are in 'initialized' or 'pending' state
  IF NEW.media_group_id IS NOT NULL 
     AND (NEW.caption IS NULL OR NEW.caption = '')
     AND NEW.analyzed_content IS NULL
     AND NEW.processing_state IN ('initialized', 'pending') THEN
    
    -- Attempt to sync from media group using the proper function with correlation_id
    PERFORM xdelo_check_media_group_content(NEW.media_group_id, NEW.id, NEW.correlation_id);
  END IF;
  
  RETURN NEW;
END;
$function$
","trigger",""
"xdelo_cleanup_orphaned_audit_logs","CREATE OR REPLACE FUNCTION public.xdelo_cleanup_orphaned_audit_logs()
 RETURNS TABLE(deleted_count bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    WITH deleted AS (
        DELETE FROM unified_audit_logs
        WHERE entity_id NOT IN (SELECT id FROM messages)
        RETURNING id
    )
    SELECT COUNT(*) FROM deleted;
END;
$function$
","TABLE(deleted_count bigint)",""
"xdelo_clear_all_messages","CREATE OR REPLACE FUNCTION public.xdelo_clear_all_messages()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  deleted_count INTEGER;
  start_time TIMESTAMP := clock_timestamp();
  result_json json;
BEGIN
  -- Delete from dependent tables first
  DELETE FROM public.deleted_messages;
  DELETE FROM public.unified_audit_logs WHERE entity_id IN (SELECT id FROM public.messages);
  DELETE FROM public.storage_validations;
  DELETE FROM public.sync_matches;
  
  -- Count and delete all messages
  WITH deleted AS (
    DELETE FROM public.messages
    RETURNING id
  )
  SELECT COUNT(*) INTO deleted_count FROM deleted;
  
  -- Log this operation
  INSERT INTO public.gl_sync_logs (
    operation,
    status,
    record_id,
    table_name,
    metadata
  ) VALUES (
    'clear_all_messages',
    'success',
    'system',
    'messages',
    jsonb_build_object(
      'deleted_count', deleted_count,
      'duration_ms', extract(epoch from (clock_timestamp() - start_time)) * 1000
    )
  );
  
  -- Build result
  result_json := json_build_object(
    'success', true,
    'deleted_count', deleted_count,
    'duration_ms', extract(epoch from (clock_timestamp() - start_time)) * 1000
  );
  
  RETURN result_json;
EXCEPTION WHEN OTHERS THEN
  -- Log error
  INSERT INTO public.gl_sync_logs (
    operation,
    status,
    record_id,
    table_name,
    error_message
  ) VALUES (
    'clear_all_messages',
    'error',
    'system',
    'messages',
    SQLERRM
  );
  
  RETURN json_build_object(
    'success', false,
    'error', SQLERRM
  );
END;
$function$
","json",""
"xdelo_complete_message_processing","CREATE OR REPLACE FUNCTION public.xdelo_complete_message_processing(p_message_id uuid, p_analyzed_content jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_message messages;
  v_media_group_id text;
  v_correlation_id uuid;
BEGIN
  -- Get the message and important metadata
  SELECT 
    media_group_id, 
    processing_correlation_id
  INTO 
    v_media_group_id, 
    v_correlation_id
  FROM messages
  WHERE id = p_message_id;
  
  -- Update the message with analyzed content and mark as completed
  UPDATE messages
  SET 
    analyzed_content = p_analyzed_content,
    processing_state = 'completed',
    processing_completed_at = NOW(),
    is_original_caption = CASE WHEN v_media_group_id IS NOT NULL THEN true ELSE is_original_caption END,
    group_caption_synced = true,
    updated_at = NOW()
  WHERE id = p_message_id;
  
  -- Log the completion
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    correlation_id,
    metadata,
    event_timestamp
  ) VALUES (
    'message_processing_completed',
    p_message_id,
    v_correlation_id::text,
    jsonb_build_object(
      'processor', 'direct-caption-processor',
      'completion_time', NOW(),
      'has_media_group', v_media_group_id IS NOT NULL
    ),
    NOW()
  );
  
  -- If the message is part of a media group, sync the content to other messages
  IF v_media_group_id IS NOT NULL THEN
    RETURN xdelo_sync_media_group_content(
      p_message_id,
      v_media_group_id,
      v_correlation_id::text,
      true -- Force sync
    );
  ELSE
    RETURN jsonb_build_object(
      'success', true,
      'message', 'Message processing completed',
      'message_id', p_message_id,
      'no_media_group', true
    );
  END IF;
END;
$function$
","jsonb","p_message_id uuid, p_analyzed_content jsonb"
"xdelo_construct_message_url_from_data","CREATE OR REPLACE FUNCTION public.xdelo_construct_message_url_from_data(telegram_data jsonb)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  base_url text := 'https://t.me/';
  processed_chat_id text;
  chat_id bigint;
  chat_type text;
  msg_id bigint;
BEGIN
  -- Extract the necessary fields directly from JSONB
  -- For messages
  IF telegram_data ? 'message' THEN
    chat_id := (telegram_data->'message'->'chat'->>'id')::bigint;
    chat_type := telegram_data->'message'->'chat'->>'type';
    msg_id := (telegram_data->'message'->>'message_id')::bigint;
  -- For channel posts
  ELSIF telegram_data ? 'channel_post' THEN
    chat_id := (telegram_data->'channel_post'->'chat'->>'id')::bigint;
    chat_type := telegram_data->'channel_post'->'chat'->>'type';
    msg_id := (telegram_data->'channel_post'->>'message_id')::bigint;
  -- For edited channel posts
  ELSIF telegram_data ? 'edited_channel_post' THEN
    chat_id := (telegram_data->'edited_channel_post'->'chat'->>'id')::bigint;
    chat_type := telegram_data->'edited_channel_post'->'chat'->>'type';
    msg_id := (telegram_data->'edited_channel_post'->>'message_id')::bigint;
  -- For edited messages
  ELSIF telegram_data ? 'edited_message' THEN
    chat_id := (telegram_data->'edited_message'->'chat'->>'id')::bigint;
    chat_type := telegram_data->'edited_message'->'chat'->>'type';
    msg_id := (telegram_data->'edited_message'->>'message_id')::bigint;
  -- If none of the above match
  ELSE
    RETURN NULL;
  END IF;

  -- Validate we have the necessary data
  IF chat_id IS NULL OR msg_id IS NULL THEN
    RETURN NULL;
  END IF;

  -- Handle URL construction based on chat type
  IF chat_type = 'private' THEN
    -- Private chats don't have shareable URLs
    RETURN NULL;
  ELSIF chat_type = 'channel' OR chat_type = 'supergroup' THEN
    -- For channels and supergroups with -100 prefix
    IF chat_id < 0 THEN
      processed_chat_id := substring(ABS(chat_id)::text, 3);
      RETURN base_url || 'c/' || processed_chat_id || '/' || msg_id;
    ELSE
      processed_chat_id := chat_id::text;
      RETURN base_url || 'c/' || processed_chat_id || '/' || msg_id;
    END IF;
  ELSIF chat_type = 'group' THEN
    -- For regular groups
    processed_chat_id := ABS(chat_id)::text;
    RETURN base_url || 'c/' || processed_chat_id || '/' || msg_id;
  ELSE
    -- Default case for other types
    RETURN NULL;
  END IF;
END;
$function$
","text","telegram_data jsonb"
"xdelo_construct_telegram_message_url","CREATE OR REPLACE FUNCTION public.xdelo_construct_telegram_message_url(chat_type telegram_chat_type, chat_id bigint, id bigint)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    base_url text := 'https://t.me/';
    processed_chat_id text;
    inferred_chat_type text;
BEGIN
    -- Infer chat type from chat_id pattern
    IF chat_id > 0 THEN
        inferred_chat_type := 'private';
    ELSIF chat_id < -100000000000 THEN
        inferred_chat_type := 'supergroup_or_channel';
    ELSIF chat_id < 0 THEN
        inferred_chat_type := 'group';
    ELSE
        inferred_chat_type := 'unknown';
    END IF;
    
    -- Handle URL construction based on inferred type
    IF inferred_chat_type = 'private' THEN
        -- Private chats don't have shareable URLs
        RETURN NULL;
    ELSIF inferred_chat_type = 'supergroup_or_channel' THEN
        -- For supergroups/channels with -100 prefix
        processed_chat_id := substring(ABS(chat_id)::text, 3);
        RETURN base_url || 'c/' || processed_chat_id || '/' || id::text;
    ELSIF inferred_chat_type = 'group' THEN
        -- For regular groups
        processed_chat_id := ABS(chat_id)::text;
        RETURN base_url || 'c/' || processed_chat_id || '/' || id::text;
    ELSE
        -- Default case
        processed_chat_id := chat_id::text;
        RETURN base_url || 'c/' || processed_chat_id || '/' || id::text;
    END IF;
END;
$function$
","text","chat_type telegram_chat_type, chat_id bigint, id bigint"
"xdelo_construct_telegram_message_url","CREATE OR REPLACE FUNCTION public.xdelo_construct_telegram_message_url(chat_type telegram_chat_type, chat_id bigint, id uuid)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    base_url text := 'https://t.me/';
    processed_chat_id text;
    inferred_chat_type text;
BEGIN
    -- Infer chat type from chat_id pattern
    IF chat_id > 0 THEN
        inferred_chat_type := 'private';
    ELSIF chat_id < -100000000000 THEN
        inferred_chat_type := 'supergroup_or_channel';
    ELSIF chat_id < 0 THEN
        inferred_chat_type := 'group';
    ELSE
        inferred_chat_type := 'unknown';
    END IF;
    
    -- Handle URL construction based on inferred type
    IF inferred_chat_type = 'private' THEN
        -- Private chats don't have shareable URLs
        RETURN NULL;
    ELSIF inferred_chat_type = 'supergroup_or_channel' THEN
        -- For supergroups/channels with -100 prefix
        processed_chat_id := substring(ABS(chat_id)::text, 3);
        RETURN base_url || 'c/' || processed_chat_id || '/' || id::text;
    ELSIF inferred_chat_type = 'group' THEN
        -- For regular groups
        processed_chat_id := ABS(chat_id)::text;
        RETURN base_url || 'c/' || processed_chat_id || '/' || id::text;
    ELSE
        -- Default case
        processed_chat_id := chat_id::text;
        RETURN base_url || 'c/' || processed_chat_id || '/' || id::text;
    END IF;
END;
$function$
","text","chat_type telegram_chat_type, chat_id bigint, id uuid"
"xdelo_ensure_edit_history_consistency","CREATE OR REPLACE FUNCTION public.xdelo_ensure_edit_history_consistency()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- If old_analyzed_content has changed and this is part of a media group
    IF NEW.old_analyzed_content IS DISTINCT FROM OLD.old_analyzed_content 
       AND NEW.media_group_id IS NOT NULL 
       AND NEW.is_original_caption = true THEN
       
        -- Sync edit history to all messages in the group
        UPDATE messages
        SET old_analyzed_content = NEW.old_analyzed_content,
            edit_history = NEW.edit_history,
            updated_at = NOW()
        WHERE media_group_id = NEW.media_group_id 
          AND id != NEW.id;
            
        -- Log the synchronization
        INSERT INTO unified_audit_logs (
            event_type,
            entity_id,
            metadata,
            correlation_id,
            event_timestamp
        ) VALUES (
            'media_group_history_synced',
            NEW.id,
            jsonb_build_object(
                'media_group_id', NEW.media_group_id,
                'synced_field', 'edit_history',
                'affected_messages_count', (
                    SELECT COUNT(*) FROM messages 
                    WHERE media_group_id = NEW.media_group_id AND id != NEW.id
                )
            ),
            COALESCE(NEW.correlation_id, gen_random_uuid()::text),
            NOW()
        );
    END IF;
    
    RETURN NULL; -- After trigger doesn't modify the row
END;
$function$
","trigger",""
"xdelo_extract_analyzed_content","CREATE OR REPLACE FUNCTION public.xdelo_extract_analyzed_content()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Only proceed if analyzed_content has changed and is not null
    IF (TG_OP = 'INSERT' OR OLD.analyzed_content IS DISTINCT FROM NEW.analyzed_content) 
       AND NEW.analyzed_content IS NOT NULL THEN
        
        -- Extract fields from analyzed_content
        NEW.product_name := NEW.analyzed_content->>'product_name';
        NEW.product_code := NEW.analyzed_content->>'product_code';
        NEW.vendor_uid := NEW.analyzed_content->>'vendor_uid';
        NEW.purchase_date := (NEW.analyzed_content->>'purchase_date')::date;
        NEW.product_quantity := (NEW.analyzed_content->>'quantity')::numeric;
        NEW.notes := NEW.analyzed_content->>'notes';
        
        -- Update modification timestamp
        NEW.updated_at := NOW();
    END IF;
    
    RETURN NEW;
END;
$function$
","trigger",""
"xdelo_extract_old_analyzed_content","CREATE OR REPLACE FUNCTION public.xdelo_extract_old_analyzed_content()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Only proceed if old_analyzed_content has changed and is not null
    IF (TG_OP = 'UPDATE' AND OLD.old_analyzed_content IS DISTINCT FROM NEW.old_analyzed_content) 
       AND OLD.old_analyzed_content IS NOT NULL THEN
        
        -- Extract fields from old_analyzed_content
        NEW.old_product_name := OLD.old_analyzed_content->>'product_name';
        NEW.old_product_code := OLD.old_analyzed_content->>'product_code';
        NEW.old_vendor_uid := OLD.old_analyzed_content->>'vendor_uid';
        NEW.old_purchase_date := (OLD.old_analyzed_content->>'purchase_date')::date;
        NEW.old_product_quantity := (OLD.old_analyzed_content->>'quantity')::numeric;
        
        -- Update modification timestamp
        NEW.updated_at := NOW();
    END IF;
    
    RETURN NEW;
END;
$function$
","trigger",""
"xdelo_fail_message_processing","CREATE OR REPLACE FUNCTION public.xdelo_fail_message_processing(p_message_id uuid, p_error_message text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_correlation_id uuid;
BEGIN
  -- Get the correlation ID for logging
  SELECT processing_correlation_id INTO v_correlation_id
  FROM messages
  WHERE id = p_message_id;
  
  -- Update the message to mark as error
  UPDATE messages
  SET 
    processing_state = 'error',
    error_message = p_error_message,
    last_error_at = NOW(),
    retry_count = COALESCE(retry_count, 0) + 1,
    updated_at = NOW()
  WHERE id = p_message_id;
  
  -- Log the error
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    correlation_id,
    error_message,
    metadata,
    event_timestamp
  ) VALUES (
    'message_processing_error',
    p_message_id,
    v_correlation_id::text,
    p_error_message,
    jsonb_build_object(
      'processor', 'direct-caption-processor',
      'error_time', NOW()
    ),
    NOW()
  );
  
  RETURN jsonb_build_object(
    'success', false,
    'error', p_error_message,
    'message_id', p_message_id
  );
END;
$function$
","jsonb","p_message_id uuid, p_error_message text"
"xdelo_find_broken_media_groups","CREATE OR REPLACE FUNCTION public.xdelo_find_broken_media_groups()
 RETURNS TABLE(media_group_id text, source_message_id uuid, total_count bigint, pending_count bigint, analyzed_count bigint)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  WITH media_group_stats AS (
    SELECT 
      mg.media_group_id,
      COUNT(*) as total_count,
      COUNT(*) FILTER (WHERE m.processing_state = 'pending') as pending_count,
      COUNT(*) FILTER (WHERE m.analyzed_content IS NOT NULL) as analyzed_count,
      -- Find a suitable source message
      (SELECT id FROM messages 
       WHERE media_group_id = mg.media_group_id 
         AND is_original_caption = true 
         AND analyzed_content IS NOT NULL
       LIMIT 1) as caption_message_id
    FROM messages m
    JOIN (
      SELECT DISTINCT media_group_id 
      FROM messages 
      WHERE media_group_id IS NOT NULL
      AND deleted_from_telegram = false
    ) mg ON m.media_group_id = mg.media_group_id
    WHERE 
      m.deleted_from_telegram = false
      AND m.media_group_id IS NOT NULL
    GROUP BY mg.media_group_id
  )
  SELECT 
    media_group_id,
    COALESCE(caption_message_id, 
      (SELECT id FROM messages 
       WHERE media_group_id = mgs.media_group_id 
         AND caption IS NOT NULL 
         AND analyzed_content IS NOT NULL
       ORDER BY created_at ASC
       LIMIT 1)
    ) as source_message_id,
    total_count,
    pending_count,
    analyzed_count
  FROM media_group_stats mgs
  WHERE 
    (pending_count > 0 AND analyzed_count > 0) -- Mixed states
    OR (analyzed_count = 0 AND pending_count > 0) -- All pending
  ORDER BY 
    pending_count DESC, 
    total_count DESC
  LIMIT 50;
END;
$function$
","TABLE(media_group_id text, source_message_id uuid, total_count bigint, pending_count bigint, analyzed_count bigint)",""
"xdelo_find_caption_message","CREATE OR REPLACE FUNCTION public.xdelo_find_caption_message(p_media_group_id text)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_message_id uuid;
BEGIN
  -- First try to find a message that already has caption and analyzed content
  SELECT id INTO v_message_id
  FROM messages
  WHERE media_group_id = p_media_group_id
    AND caption IS NOT NULL
    AND caption != ''
    AND analyzed_content IS NOT NULL
    AND is_original_caption = true
  ORDER BY created_at ASC
  LIMIT 1;
  
  IF v_message_id IS NOT NULL THEN
    RETURN v_message_id;
  END IF;
  
  -- If not found, try to find a message with caption but no analyzed content
  SELECT id INTO v_message_id
  FROM messages
  WHERE media_group_id = p_media_group_id
    AND caption IS NOT NULL
    AND caption != ''
  ORDER BY created_at ASC
  LIMIT 1;
  
  IF v_message_id IS NOT NULL THEN
    RETURN v_message_id;
  END IF;
  
  -- If still not found, return NULL
  RETURN NULL;
END;
$function$
","uuid","p_media_group_id text"
"xdelo_find_valid_file_id","CREATE OR REPLACE FUNCTION public.xdelo_find_valid_file_id(p_media_group_id text, p_file_unique_id text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_file_id text;
    v_current_time timestamp;
BEGIN
    SET search_path = 'public';

    v_current_time := NOW();

    -- First try to find a non-expired file_id for the same file_unique_id
    SELECT file_id INTO v_file_id
    FROM messages
    WHERE media_group_id = p_media_group_id
    AND file_unique_id = p_file_unique_id
    AND file_id IS NOT NULL
    AND (file_id_expires_at IS NULL OR file_id_expires_at > v_current_time)
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_file_id IS NOT NULL THEN
        RETURN v_file_id;
    END IF;

    -- If not found, look for any recent file_id in the media group
    SELECT file_id INTO v_file_id
    FROM messages
    WHERE media_group_id = p_media_group_id
    AND file_id IS NOT NULL
    AND (file_id_expires_at IS NULL OR file_id_expires_at > v_current_time)
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_file_id IS NOT NULL THEN
        RETURN v_file_id;
    END IF;

    -- As a last resort, return any file_id even if expired
    SELECT file_id INTO v_file_id
    FROM messages
    WHERE media_group_id = p_media_group_id
    AND file_unique_id = p_file_unique_id
    AND file_id IS NOT NULL
    ORDER BY created_at DESC
    LIMIT 1;

    RETURN v_file_id;
END;
$function$
","text","p_media_group_id text, p_file_unique_id text"
"xdelo_fix_public_urls","CREATE OR REPLACE FUNCTION public.xdelo_fix_public_urls(p_limit integer DEFAULT 100)
 RETURNS TABLE(message_id uuid, old_url text, new_url text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  WITH updated_messages AS (
    UPDATE messages
    SET 
      public_url = 'https://xjhhehxcxkiumnwbirel.supabase.co/storage/v1/object/public/telegram-media/' || storage_path,
      updated_at = NOW()
    WHERE 
      storage_path IS NOT NULL 
      AND storage_path != '' 
      AND (
        public_url IS NULL 
        OR public_url = '' 
        OR public_url NOT LIKE '%/storage/v1/object/public/%'
      )
    RETURNING id, public_url, storage_path
  )
  SELECT 
    id, 
    'invalid_or_missing'::text, 
    public_url
  FROM updated_messages;
END;
$function$
","TABLE(message_id uuid, old_url text, new_url text)","p_limit integer DEFAULT 100"
"xdelo_flag_file_for_redownload","CREATE OR REPLACE FUNCTION public.xdelo_flag_file_for_redownload(p_message_id uuid, p_reason text DEFAULT 'file_missing'::text)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_success BOOLEAN := false;
BEGIN
  -- Update the message to indicate it needs redownload
  UPDATE messages
  SET 
    needs_redownload = true,
    redownload_reason = p_reason,
    redownload_attempts = COALESCE(redownload_attempts, 0),
    redownload_flagged_at = NOW()
  WHERE id = p_message_id;
  
  -- Log the redownload flag
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    metadata,
    event_timestamp
  ) VALUES (
    'file_redownload_flagged',
    p_message_id,
    jsonb_build_object(
      'reason', p_reason,
      'flagged_at', NOW()
    ),
    NOW()
  );
  
  v_success := true;
  RETURN v_success;
EXCEPTION
  WHEN OTHERS THEN
    RETURN false;
END;
$function$
","boolean","p_message_id uuid, p_reason text DEFAULT 'file_missing'::text"
"xdelo_get_incomplete_media_groups","CREATE OR REPLACE FUNCTION public.xdelo_get_incomplete_media_groups(limit_param integer DEFAULT 10)
 RETURNS TABLE(media_group_id text, total_messages integer, processed_messages integer, unprocessed_messages integer, oldest_message_id uuid, oldest_message_created_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  WITH media_group_stats AS (
    SELECT 
      mg.media_group_id,
      COUNT(*) AS total_messages,
      COUNT(*) FILTER (WHERE m.analyzed_content IS NOT NULL) AS processed_messages,
      COUNT(*) FILTER (WHERE m.analyzed_content IS NULL) AS unprocessed_messages,
      MIN(m.created_at) AS oldest_created_at
    FROM (
      SELECT DISTINCT media_group_id 
      FROM messages 
      WHERE media_group_id IS NOT NULL
    ) mg
    JOIN messages m ON m.media_group_id = mg.media_group_id
    GROUP BY mg.media_group_id
    HAVING 
      COUNT(*) FILTER (WHERE m.analyzed_content IS NOT NULL) > 0 
      AND COUNT(*) FILTER (WHERE m.analyzed_content IS NULL) > 0
    ORDER BY MIN(m.created_at) ASC
    LIMIT limit_param
  ),
  oldest_messages AS (
    SELECT DISTINCT ON (m.media_group_id)
      m.media_group_id,
      m.id AS oldest_message_id,
      m.created_at AS oldest_message_created_at
    FROM messages m
    JOIN media_group_stats mgs ON m.media_group_id = mgs.media_group_id
    WHERE m.created_at = mgs.oldest_created_at
    ORDER BY m.media_group_id, m.created_at ASC
  )
  SELECT
    mgs.media_group_id,
    mgs.total_messages,
    mgs.processed_messages,
    mgs.unprocessed_messages,
    om.oldest_message_id,
    om.oldest_message_created_at
  FROM media_group_stats mgs
  JOIN oldest_messages om ON mgs.media_group_id = om.media_group_id
  ORDER BY om.oldest_message_created_at ASC;
END;
$function$
","TABLE(media_group_id text, total_messages integer, processed_messages integer, unprocessed_messages integer, oldest_message_id uuid, oldest_message_created_at timestamp with time zone)","limit_param integer DEFAULT 10"
"xdelo_get_logger","CREATE OR REPLACE FUNCTION public.xdelo_get_logger(p_correlation_id text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN jsonb_build_object(
    'info', jsonb_build_object(
      'fn', 'log',
      'correlation_id', p_correlation_id
    ),
    'warn', jsonb_build_object(
      'fn', 'warn',
      'correlation_id', p_correlation_id
    ),
    'error', jsonb_build_object(
      'fn', 'error',
      'correlation_id', p_correlation_id
    )
  );
END;
$function$
","jsonb","p_correlation_id text"
"xdelo_get_message_for_processing","CREATE OR REPLACE FUNCTION public.xdelo_get_message_for_processing(p_message_id uuid)
 RETURNS TABLE(id uuid, telegram_message_id bigint, caption text, media_group_id text, processing_state text, analyzed_content jsonb, old_analyzed_content jsonb[], is_original_caption boolean, correlation_id uuid)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    m.id,
    m.telegram_message_id,
    m.caption,
    m.media_group_id,
    m.processing_state::text,
    m.analyzed_content,
    m.old_analyzed_content,
    m.is_original_caption,
    m.processing_correlation_id
  FROM messages m
  WHERE m.id = p_message_id;
END;
$function$
","TABLE(id uuid, telegram_message_id bigint, caption text, media_group_id text, processing_state text, analyzed_content jsonb, old_analyzed_content jsonb[], is_original_caption boolean, correlation_id uuid)","p_message_id uuid"
"xdelo_get_message_forward_history","CREATE OR REPLACE FUNCTION public.xdelo_get_message_forward_history(p_message_id uuid)
 RETURNS TABLE(message_id uuid, telegram_message_id bigint, chat_id bigint, forward_date timestamp with time zone, analyzed_content jsonb, forward_count integer)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    WITH RECURSIVE forward_tree AS (
        -- Base case: get the original message
        SELECT 
            m.id,
            m.telegram_message_id,
            m.chat_id,
            m.created_at as forward_date,
            m.analyzed_content,
            m.forward_count,
            m.forward_chain
        FROM messages m
        WHERE m.id = p_message_id

        UNION ALL

        -- Recursive case: get all forwards
        SELECT 
            m.id,
            m.telegram_message_id,
            m.chat_id,
            m.created_at as forward_date,
            m.analyzed_content,
            m.forward_count,
            m.forward_chain
        FROM messages m
        INNER JOIN forward_tree ft ON m.original_message_id = ft.id
        WHERE m.is_forward = true
    )
    SELECT 
        id,
        telegram_message_id,
        chat_id,
        forward_date,
        analyzed_content,
        forward_count
    FROM forward_tree
    ORDER BY forward_date DESC;
END;
$function$
","TABLE(message_id uuid, telegram_message_id bigint, chat_id bigint, forward_date timestamp with time zone, analyzed_content jsonb, forward_count integer)","p_message_id uuid"
"xdelo_get_product_matching_config","CREATE OR REPLACE FUNCTION public.xdelo_get_product_matching_config()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_config JSONB;
BEGIN
  SELECT jsonb_build_object(
    'similarityThreshold', similarity_threshold,
    'partialMatch', jsonb_build_object(
      'enabled', partial_match_enabled,
      'minLength', partial_match_min_length,
      'dateFormat', partial_match_date_format
    ),
    'weightedScoring', jsonb_build_object(
      'name', weight_name,
      'vendor', weight_vendor,
      'purchaseDate', weight_purchase_date
    )
  ) INTO v_config
  FROM product_matching_config
  ORDER BY created_at DESC
  LIMIT 1;
  
  -- Return default config if none exists
  IF v_config IS NULL THEN
    v_config := jsonb_build_object(
      'similarityThreshold', 0.7,
      'partialMatch', jsonb_build_object(
        'enabled', true,
        'minLength', 2,
        'dateFormat', 'YYYY-MM-DD'
      ),
      'weightedScoring', jsonb_build_object(
        'name', 0.4,
        'vendor', 0.3,
        'purchaseDate', 0.3
      )
    );
  END IF;
  
  RETURN v_config;
END;
$function$
","jsonb",""
"xdelo_handle_duplicate_detection","CREATE OR REPLACE FUNCTION public.xdelo_handle_duplicate_detection(p_file_unique_id text, p_telegram_message_id bigint, p_chat_id bigint, p_correlation_id text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_existing_message messages;
    v_is_duplicate BOOLEAN := false;
    v_duplicate_id UUID;
BEGIN
    -- Check if we have a message with the same file_unique_id
    SELECT * INTO v_existing_message
    FROM messages
    WHERE file_unique_id = p_file_unique_id
    AND (
        telegram_message_id != p_telegram_message_id OR
        chat_id != p_chat_id
    )
    ORDER BY created_at ASC
    LIMIT 1;
    
    IF FOUND THEN
        v_is_duplicate := true;
        v_duplicate_id := v_existing_message.id;
        
        -- Log duplicate detection
        INSERT INTO unified_audit_logs (
            event_type,
            entity_id,
            metadata,
            correlation_id
        ) VALUES (
            'duplicate_detected',
            v_existing_message.id,
            jsonb_build_object(
                'file_unique_id', p_file_unique_id,
                'new_telegram_message_id', p_telegram_message_id,
                'new_chat_id', p_chat_id
            ),
            p_correlation_id
        );
    END IF;
    
    RETURN jsonb_build_object(
        'is_duplicate', v_is_duplicate,
        'original_message_id', v_duplicate_id,
        'file_unique_id', p_file_unique_id
    );
END;
$function$
","jsonb","p_file_unique_id text, p_telegram_message_id bigint, p_chat_id bigint, p_correlation_id text DEFAULT NULL::text"
"xdelo_handle_forward_media","CREATE OR REPLACE FUNCTION public.xdelo_handle_forward_media()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only proceed if this is a forward and we have the original message
  IF NEW.is_forward AND NEW.original_message_id IS NOT NULL THEN
    -- Sync media from original message
    PERFORM xdelo_sync_forward_media(NEW.original_message_id, NEW.id);
  END IF;
  RETURN NEW;
END;
$function$
","trigger",""
"xdelo_handle_message_edit","CREATE OR REPLACE FUNCTION public.xdelo_handle_message_edit()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- If caption changed, this will trigger a re-analysis
    IF NEW.caption != OLD.caption OR (NEW.caption IS NOT NULL AND OLD.caption IS NULL) THEN
        -- Reset analysis state
        NEW.analyzed_content = NULL;
        NEW.processing_state = 'pending';
        NEW.group_caption_synced = false;
        
        -- Add to edit history
        NEW.edit_history = COALESCE(OLD.edit_history, '[]'::jsonb) || jsonb_build_object(
            'edit_date', CURRENT_TIMESTAMP,
            'previous_caption', OLD.caption,
            'new_caption', NEW.caption,
            'is_channel_post', NEW.chat_type = 'channel'
        );
        
        -- Log the edit
        INSERT INTO unified_audit_logs (
            event_type,
            entity_id,
            telegram_message_id,
            chat_id,
            previous_state,
            new_state,
            metadata
        ) VALUES (
            'message_edited',
            NEW.id,
            NEW.telegram_message_id,
            NEW.chat_id,
            jsonb_build_object('caption', OLD.caption, 'analyzed_content', OLD.analyzed_content),
            jsonb_build_object('caption', NEW.caption),
            jsonb_build_object(
                'media_group_id', NEW.media_group_id,
                'is_channel_post', NEW.chat_type = 'channel'
            )
        );
        
        -- If part of media group, update all related messages
        IF NEW.media_group_id IS NOT NULL THEN
            UPDATE messages
            SET 
                analyzed_content = NULL,
                processing_state = 'pending',
                group_caption_synced = false,
                updated_at = CURRENT_TIMESTAMP
            WHERE 
                media_group_id = NEW.media_group_id 
                AND id != NEW.id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
","trigger",""
"xdelo_handle_message_forward","CREATE OR REPLACE FUNCTION public.xdelo_handle_message_forward()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_original_message messages;
    v_forward_data jsonb;
BEGIN
    -- Only proceed if we don't already know it's a forward
    IF NEW.is_forward IS NULL OR NEW.is_forward = false THEN
        -- Look for the original message
        SELECT * INTO v_original_message
        FROM messages
        WHERE file_unique_id = NEW.file_unique_id
        AND id != NEW.id
        AND deleted_from_telegram = false
        ORDER BY created_at ASC
        LIMIT 1;

        IF FOUND THEN
            -- Mark as forwarded
            NEW.is_forward := true;
            NEW.forward_count := COALESCE(v_original_message.forward_count, 0) + 1;
            
            -- Set original message reference
            IF v_original_message.original_message_id IS NOT NULL THEN
                NEW.original_message_id := v_original_message.original_message_id;
            ELSE
                NEW.original_message_id := v_original_message.id;
            END IF;

            -- Create forward history entry
            v_forward_data := jsonb_build_object(
                'forward_date', CURRENT_TIMESTAMP,
                'from_chat_id', NEW.chat_id,
                'from_message_id', NEW.telegram_message_id,
                'previous_message_id', v_original_message.id,
                'forward_count', NEW.forward_count,
                'forward_from', NEW.forward_from,
                'forward_from_chat', NEW.forward_from_chat
            );

            -- Update forward chain
            NEW.forward_chain := array_append(
                COALESCE(v_original_message.forward_chain, ARRAY[]::jsonb[]),
                v_forward_data
            );

            -- Copy analyzed content to history if it exists
            IF v_original_message.analyzed_content IS NOT NULL THEN
                NEW.old_analyzed_content := array_append(
                    COALESCE(v_original_message.old_analyzed_content, ARRAY[]::jsonb[]),
                    v_original_message.analyzed_content
                );
            END IF;

            -- Reset processing state
            NEW.analyzed_content := NULL;
            NEW.processing_state := 'pending';
            NEW.processing_started_at := NULL;
            NEW.processing_completed_at := NULL;
            NEW.group_caption_synced := false;

            -- Log the forward
            PERFORM xdelo_log_event(
                'message_forwarded'::audit_event_type,
                NEW.id,
                NEW.telegram_message_id,
                NEW.chat_id,
                NULL,
                jsonb_build_object(
                    'original_message_id', NEW.original_message_id,
                    'forward_count', NEW.forward_count,
                    'forward_from', NEW.forward_from,
                    'forward_from_chat', NEW.forward_from_chat
                ),
                v_forward_data,
                NEW.correlation_id
            );
        END IF;
    END IF;

    RETURN NEW;
END;
$function$
","trigger",""
"xdelo_handle_message_update","CREATE OR REPLACE FUNCTION public.xdelo_handle_message_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- If caption changed, this will trigger a re-analysis
    IF NEW.caption != OLD.caption OR (NEW.caption IS NOT NULL AND OLD.caption IS NULL) THEN
        -- Store previous analyzed content in the array if it exists
        IF OLD.analyzed_content IS NOT NULL THEN
            NEW.old_analyzed_content = array_append(
                COALESCE(OLD.old_analyzed_content, ARRAY[]::jsonb[]),
                OLD.analyzed_content
            );
        END IF;
        
        -- Reset analysis state
        NEW.analyzed_content = NULL;
        NEW.processing_state = 'pending';
        NEW.group_caption_synced = false;
        
        -- Add to edit history
        NEW.edit_history = COALESCE(OLD.edit_history, '[]'::jsonb) || jsonb_build_object(
            'edit_date', CURRENT_TIMESTAMP,
            'previous_caption', OLD.caption,
            'new_caption', NEW.caption,
            'is_channel_post', NEW.chat_type = 'channel',
            'previous_analyzed_content', OLD.analyzed_content
        );
        
        -- Log the edit
        PERFORM xdelo_log_event(
            'message_edited'::audit_event_type,
            NEW.id,
            NEW.telegram_message_id,
            NEW.chat_id,
            jsonb_build_object('caption', OLD.caption, 'analyzed_content', OLD.analyzed_content),
            jsonb_build_object('caption', NEW.caption),
            jsonb_build_object(
                'media_group_id', NEW.media_group_id,
                'is_channel_post', NEW.chat_type = 'channel'
            ),
            NEW.correlation_id
        );
        
        -- If part of media group, update all related messages
        IF NEW.media_group_id IS NOT NULL THEN
            UPDATE messages
            SET 
                analyzed_content = NULL,
                processing_state = 'pending',
                group_caption_synced = false,
                updated_at = CURRENT_TIMESTAMP
            WHERE 
                media_group_id = NEW.media_group_id 
                AND id != NEW.id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
","trigger",""
"xdelo_handle_message_update","CREATE OR REPLACE FUNCTION public.xdelo_handle_message_update(p_message_id uuid, p_caption text, p_is_edit boolean DEFAULT false, p_correlation_id text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_message messages;
    v_result JSONB;
    v_edit_history JSONB;
BEGIN
    -- Get the current message
    SELECT * INTO v_message
    FROM messages
    WHERE id = p_message_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Message not found: %', p_message_id;
    END IF;
    
    -- Prepare edit history if this is an edit
    IF p_is_edit THEN
        -- Initialize edit history if it doesn't exist
        IF v_message.edit_history IS NULL THEN
            v_edit_history := jsonb_build_array();
        ELSE
            v_edit_history := v_message.edit_history;
        END IF;
        
        -- Add the current state to edit history
        v_edit_history := v_edit_history || jsonb_build_object(
            'timestamp', NOW(),
            'previous_caption', v_message.caption,
            'previous_analyzed_content', v_message.analyzed_content
        );
        
        -- Update the message
        UPDATE messages
        SET 
            caption = p_caption,
            analyzed_content = NULL, -- Reset analyzed content since caption changed
            processing_state = 'pending',
            edit_history = v_edit_history,
            edit_count = COALESCE(edit_count, 0) + 1,
            edit_date = NOW(),
            is_edited = true,
            group_caption_synced = false,
            correlation_id = COALESCE(p_correlation_id, correlation_id)
        WHERE id = p_message_id;
        
        -- Log the edit
        INSERT INTO unified_audit_logs (
            event_type,
            entity_id,
            previous_state,
            new_state,
            metadata,
            correlation_id
        ) VALUES (
            'message_edited',
            p_message_id,
            jsonb_build_object(
                'caption', v_message.caption,
                'analyzed_content', v_message.analyzed_content
            ),
            jsonb_build_object(
                'caption', p_caption
            ),
            jsonb_build_object(
                'is_edit', true,
                'edit_count', COALESCE(v_message.edit_count, 0) + 1
            ),
            p_correlation_id
        );
        
        -- If this is part of a media group, we need to update the other messages too
        IF v_message.media_group_id IS NOT NULL THEN
            -- Update all other messages in the group
            UPDATE messages
            SET 
                analyzed_content = NULL,
                processing_state = 'pending',
                group_caption_synced = false
            WHERE 
                media_group_id = v_message.media_group_id 
                AND id != p_message_id;
        END IF;
    ELSE
        -- Just update the caption without edit history
        UPDATE messages
        SET 
            caption = p_caption,
            updated_at = NOW(),
            correlation_id = COALESCE(p_correlation_id, correlation_id)
        WHERE id = p_message_id;
    END IF;
    
    -- Return success result
    RETURN jsonb_build_object(
        'success', true,
        'message_id', p_message_id,
        'is_edit', p_is_edit
    );
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'message_id', p_message_id,
            'error', SQLERRM
        );
END;
$function$
","jsonb","p_message_id uuid, p_caption text, p_is_edit boolean DEFAULT false, p_correlation_id text DEFAULT NULL::text"
"xdelo_handle_updated_at","CREATE OR REPLACE FUNCTION public.xdelo_handle_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
","trigger",""
"xdelo_has_valid_caption","CREATE OR REPLACE FUNCTION public.xdelo_has_valid_caption(p_caption text)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Check if caption exists and isn't empty
  RETURN p_caption IS NOT NULL AND trim(p_caption) <> '';
END;
$function$
","boolean","p_caption text"
"xdelo_log_deleted_message","CREATE OR REPLACE FUNCTION public.xdelo_log_deleted_message()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Store deleted message in deleted_messages table
    INSERT INTO deleted_messages (
        original_message_id,
        telegram_message_id,
        media_group_id,
        message_caption_id,
        caption,
        file_id,
        file_unique_id,
        public_url,
        mime_type,
        analyzed_content,
        telegram_data,
        deleted_from_telegram,
        deleted_via_telegram,
        user_id
    ) VALUES (
        OLD.id,
        OLD.telegram_message_id,
        OLD.media_group_id,
        OLD.message_caption_id,
        OLD.caption,
        OLD.file_id,
        OLD.file_unique_id,
        OLD.public_url,
        OLD.mime_type,
        OLD.analyzed_content,
        OLD.telegram_data,
        OLD.deleted_from_telegram,
        false, -- Not deleted via Telegram
        OLD.user_id
    );
    
    -- Log the deletion event
    INSERT INTO unified_audit_logs (
        event_type,
        entity_id,
        telegram_message_id,
        chat_id,
        previous_state,
        metadata,
        correlation_id,
        user_id
    ) VALUES (
        'message_deleted',
        OLD.id,
        OLD.telegram_message_id,
        OLD.chat_id,
        to_jsonb(OLD),
        jsonb_build_object(
            'media_group_id', OLD.media_group_id,
            'is_original_caption', OLD.is_original_caption,
            'deletion_type', 'database'
        ),
        OLD.correlation_id,
        OLD.user_id
    );

    RETURN OLD;
END;
$function$
","trigger",""
"xdelo_log_event","CREATE OR REPLACE FUNCTION public.xdelo_log_event(p_event_type audit_event_type, p_entity_id uuid, p_telegram_message_id bigint DEFAULT NULL::bigint, p_chat_id bigint DEFAULT NULL::bigint, p_previous_state jsonb DEFAULT NULL::jsonb, p_new_state jsonb DEFAULT NULL::jsonb, p_metadata jsonb DEFAULT NULL::jsonb, p_correlation_id text DEFAULT NULL::text, p_user_id uuid DEFAULT NULL::uuid, p_error_message text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO unified_audit_logs (
        event_type,
        entity_id,
        telegram_message_id,
        chat_id,
        previous_state,
        new_state,
        metadata,
        correlation_id,
        user_id,
        error_message
    ) VALUES (
        p_event_type,
        p_entity_id,
        p_telegram_message_id,
        p_chat_id,
        p_previous_state,
        p_new_state,
        p_metadata,
        p_correlation_id,
        p_user_id,
        p_error_message
    );
END;
$function$
","void","p_event_type audit_event_type, p_entity_id uuid, p_telegram_message_id bigint DEFAULT NULL::bigint, p_chat_id bigint DEFAULT NULL::bigint, p_previous_state jsonb DEFAULT NULL::jsonb, p_new_state jsonb DEFAULT NULL::jsonb, p_metadata jsonb DEFAULT NULL::jsonb, p_correlation_id text DEFAULT NULL::text, p_user_id uuid DEFAULT NULL::uuid, p_error_message text DEFAULT NULL::text"
"xdelo_log_event_flexible","CREATE OR REPLACE FUNCTION public.xdelo_log_event_flexible(p_event_type text, p_entity_id uuid, p_telegram_message_id bigint DEFAULT NULL::bigint, p_chat_id bigint DEFAULT NULL::bigint, p_previous_state jsonb DEFAULT NULL::jsonb, p_new_state jsonb DEFAULT NULL::jsonb, p_metadata jsonb DEFAULT NULL::jsonb, p_correlation_id text DEFAULT NULL::text, p_user_id uuid DEFAULT NULL::uuid, p_error_message text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Instead of requiring an enum cast, store the event type as text
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    telegram_message_id,
    chat_id,
    previous_state,
    new_state,
    metadata,
    correlation_id,
    user_id,
    error_message
  ) VALUES (
    p_event_type,
    p_entity_id,
    p_telegram_message_id,
    p_chat_id,
    p_previous_state,
    p_new_state,
    p_metadata,
    p_correlation_id,
    p_user_id,
    p_error_message
  );
END;
$function$
","void","p_event_type text, p_entity_id uuid, p_telegram_message_id bigint DEFAULT NULL::bigint, p_chat_id bigint DEFAULT NULL::bigint, p_previous_state jsonb DEFAULT NULL::jsonb, p_new_state jsonb DEFAULT NULL::jsonb, p_metadata jsonb DEFAULT NULL::jsonb, p_correlation_id text DEFAULT NULL::text, p_user_id uuid DEFAULT NULL::uuid, p_error_message text DEFAULT NULL::text"
"xdelo_log_message_operation","CREATE OR REPLACE FUNCTION public.xdelo_log_message_operation(p_operation text, p_message_id uuid, p_details jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Call the consolidated logging function
  PERFORM xdelo_log_operation(
    p_operation,
    p_message_id,
    p_details
  );
END;
$function$
","void","p_operation text, p_message_id uuid, p_details jsonb"
"xdelo_log_message_operation","CREATE OR REPLACE FUNCTION public.xdelo_log_message_operation(p_operation text, p_message_id text, p_metadata jsonb DEFAULT '{}'::jsonb, p_error_message text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_log_id uuid;
BEGIN
  INSERT INTO public.unified_audit_logs (
    event_type,
    entity_id,
    metadata,
    error_message
  ) VALUES (
    p_operation,
    p_message_id,
    p_metadata,
    p_error_message
  )
  RETURNING id INTO v_log_id;
  
  RETURN v_log_id;
END;
$function$
","uuid","p_operation text, p_message_id text, p_metadata jsonb DEFAULT '{}'::jsonb, p_error_message text DEFAULT NULL::text"
"xdelo_log_message_operation","CREATE OR REPLACE FUNCTION public.xdelo_log_message_operation(p_operation_type message_operation_type, p_source_message_id uuid, p_target_message_id uuid DEFAULT NULL::uuid, p_correlation_id text DEFAULT NULL::text, p_telegram_message_id bigint DEFAULT NULL::bigint, p_chat_id bigint DEFAULT NULL::bigint, p_metadata jsonb DEFAULT NULL::jsonb, p_user_id uuid DEFAULT NULL::uuid, p_error_message text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_source_valid boolean;
  v_target_valid boolean;
  v_log_id uuid;
  v_event_type audit_event_type;
BEGIN
  -- Validate source message ID
  IF p_source_message_id IS NOT NULL THEN
    v_source_valid := public.xdelo_validate_message_ids(p_source_message_id);
    IF NOT v_source_valid THEN
      RAISE WARNING 'Source message ID % does not exist', p_source_message_id;
    END IF;
  END IF;
  
  -- Validate target message ID if provided
  IF p_target_message_id IS NOT NULL THEN
    v_target_valid := public.xdelo_validate_message_ids(p_target_message_id);
    IF NOT v_target_valid THEN
      RAISE WARNING 'Target message ID % does not exist', p_target_message_id;
    END IF;
  END IF;
  
  -- Map operation_type to event_type
  CASE p_operation_type
    WHEN 'message_create' THEN v_event_type := 'message_created'::audit_event_type;
    WHEN 'message_update' THEN v_event_type := 'message_updated'::audit_event_type;
    WHEN 'message_delete' THEN v_event_type := 'message_deleted'::audit_event_type;
    WHEN 'message_forward' THEN v_event_type := 'webhook_received'::audit_event_type;
    WHEN 'message_edit' THEN v_event_type := 'message_updated'::audit_event_type;
    WHEN 'media_redownload' THEN v_event_type := 'webhook_received'::audit_event_type;
    WHEN 'caption_change' THEN v_event_type := 'message_updated'::audit_event_type;
    WHEN 'media_change' THEN v_event_type := 'message_updated'::audit_event_type;
    WHEN 'group_sync' THEN v_event_type := 'media_group_synced'::audit_event_type;
    ELSE v_event_type := 'webhook_received'::audit_event_type;
  END CASE;
  
  -- Insert log entry
  INSERT INTO public.unified_audit_logs (
    event_type,
    entity_id,
    source_message_id,
    target_message_id,
    operation_type,
    telegram_message_id,
    chat_id,
    metadata,
    correlation_id,
    user_id,
    error_message
  ) VALUES (
    v_event_type,
    COALESCE(p_source_message_id, p_target_message_id), -- Use one of the IDs as the entity_id
    p_source_message_id,
    p_target_message_id,
    p_operation_type,
    p_telegram_message_id,
    p_chat_id,
    p_metadata,
    p_correlation_id,
    p_user_id,
    p_error_message
  )
  RETURNING id INTO v_log_id;
  
  RETURN v_log_id;
END;
$function$
","uuid","p_operation_type message_operation_type, p_source_message_id uuid, p_target_message_id uuid DEFAULT NULL::uuid, p_correlation_id text DEFAULT NULL::text, p_telegram_message_id bigint DEFAULT NULL::bigint, p_chat_id bigint DEFAULT NULL::bigint, p_metadata jsonb DEFAULT NULL::jsonb, p_user_id uuid DEFAULT NULL::uuid, p_error_message text DEFAULT NULL::text"
"xdelo_log_operation","CREATE OR REPLACE FUNCTION public.xdelo_log_operation(p_event_type text, p_entity_id uuid, p_metadata jsonb DEFAULT NULL::jsonb, p_previous_state jsonb DEFAULT NULL::jsonb, p_new_state jsonb DEFAULT NULL::jsonb, p_error_message text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    metadata,
    previous_state,
    new_state,
    error_message,
    event_timestamp
  ) VALUES (
    p_event_type,
    p_entity_id,
    p_metadata,
    p_previous_state,
    p_new_state,
    p_error_message,
    now()
  );
EXCEPTION
  WHEN others THEN
    -- Silently fail as this is just logging
    RAISE NOTICE 'Error in unified logging: %', SQLERRM;
END;
$function$
","void","p_event_type text, p_entity_id uuid, p_metadata jsonb DEFAULT NULL::jsonb, p_previous_state jsonb DEFAULT NULL::jsonb, p_new_state jsonb DEFAULT NULL::jsonb, p_error_message text DEFAULT NULL::text"
"xdelo_log_webhook_event","CREATE OR REPLACE FUNCTION public.xdelo_log_webhook_event(p_event_type text, p_chat_id bigint, p_message_id uuid, p_media_type text DEFAULT NULL::text, p_error_message text DEFAULT NULL::text, p_raw_data jsonb DEFAULT NULL::jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO webhook_logs (
        event_type,
        chat_id,
        message_id,
        media_type,
        error_message,
        raw_data
    ) VALUES (
        p_event_type,
        p_chat_id,
        p_message_id,
        p_media_type,
        p_error_message,
        p_raw_data
    );
END;
$function$
","void","p_event_type text, p_chat_id bigint, p_message_id uuid, p_media_type text DEFAULT NULL::text, p_error_message text DEFAULT NULL::text, p_raw_data jsonb DEFAULT NULL::jsonb"
"xdelo_mark_for_redownload","CREATE OR REPLACE FUNCTION public.xdelo_mark_for_redownload(p_message_id uuid, p_reason text DEFAULT 'File missing or corrupted'::text)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_message messages;
    v_strategy TEXT;
BEGIN
    SET search_path = 'public';

    -- Get the message
    SELECT * INTO v_message
    FROM messages
    WHERE id = p_message_id;

    IF NOT FOUND THEN
        RETURN FALSE;
    END IF;

    -- Determine the best redownload strategy
    IF v_message.media_group_id IS NOT NULL THEN
        v_strategy := 'media_group';
    ELSIF v_message.file_id IS NOT NULL AND 
          (v_message.file_id_expires_at IS NULL OR v_message.file_id_expires_at > NOW()) THEN
        v_strategy := 'telegram_api';
    ELSE
        v_strategy := 'manual';
    END IF;

    -- Update the message
    UPDATE messages
    SET 
        needs_redownload = TRUE,
        redownload_reason = p_reason,
        redownload_flagged_at = NOW(),
        redownload_strategy = v_strategy
    WHERE id = p_message_id;

    RETURN TRUE;
END;
$function$
","boolean","p_message_id uuid, p_reason text DEFAULT 'File missing or corrupted'::text"
"xdelo_parse_caption","CREATE OR REPLACE FUNCTION public.xdelo_parse_caption(p_caption text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_timestamp timestamptz := now();
  v_trimmed_caption text := trim(p_caption);
  v_result jsonb;
  v_missing_fields text[] := '{}';
  v_product_name text := '';
  v_product_code text := '';
  v_vendor_uid text := null;
  v_purchase_date text := null;
  v_quantity int := null;
  v_notes text := '';
  v_partial_success boolean := false;
  v_quantity_pattern text := null;
BEGIN
  -- Initialize the result object
  v_result := jsonb_build_object(
    'product_name', '',
    'product_code', '',
    'vendor_uid', null,
    'purchase_date', null,
    'quantity', null,
    'notes', '',
    'caption', v_trimmed_caption,
    'parsing_metadata', jsonb_build_object(
      'method', 'manual',
      'timestamp', v_timestamp,
      'partial_success', false
    )
  );
  
  -- Handle empty captions
  IF v_trimmed_caption IS NULL OR v_trimmed_caption = '' THEN
    v_result := jsonb_set(v_result, '{parsing_metadata,error}', to_jsonb('Empty caption'));
    v_result := jsonb_set(v_result, '{parsing_metadata,partial_success}', to_jsonb(true));
    v_result := jsonb_set(v_result, '{parsing_metadata,missing_fields}', 
                         to_jsonb(ARRAY['product_name', 'product_code', 'vendor_uid', 'purchase_date', 'quantity']));
    RETURN v_result;
  END IF;
  
  -- Handle multiple lines
  IF position(E'\n' in v_trimmed_caption) > 0 THEN
    -- Multi-line caption
    DECLARE 
      v_lines text[] := string_to_array(v_trimmed_caption, E'\n');
      v_code_line_idx int := -1;
      i int;
    BEGIN
      -- Extract product name from first line
      IF array_length(v_lines, 1) > 0 THEN
        v_product_name := trim(regexp_replace(v_lines[1], '^[''"]|[''"]$', '', 'g'));
      ELSE
        v_missing_fields := array_append(v_missing_fields, 'product_name');
      END IF;
      
      -- Find line with product code
      FOR i IN 1..array_length(v_lines, 1) LOOP
        IF position('#' in v_lines[i]) > 0 THEN
          v_code_line_idx := i;
          EXIT;
        END IF;
      END LOOP;
      
      -- If found a line with product code
      IF v_code_line_idx > 0 THEN
        DECLARE
          v_code_match text;
        BEGIN
          v_code_match := substring(v_lines[v_code_line_idx] from '#([A-Za-z0-9-]+)');
          
          IF v_code_match IS NOT NULL THEN
            v_product_code := v_code_match;
            
            -- Extract vendor and date
            -- Vendor UID (first 1-4 letters)
            v_vendor_uid := upper(substring(v_code_match from '^([A-Za-z]{1,4})'));
            
            IF v_vendor_uid IS NULL THEN
              v_missing_fields := array_append(v_missing_fields, 'vendor_uid');
            END IF;
            
            -- Purchase date (digits after vendor letters)
            DECLARE
              v_date_digits text;
            BEGIN
              v_date_digits := substring(v_code_match from '^[A-Za-z]{1,4}(\d{5,6})');
              
              IF v_date_digits IS NOT NULL THEN
                BEGIN
                  -- Format the date (mmDDyy -> YYYY-MM-DD)
                  IF length(v_date_digits) = 5 THEN
                    v_date_digits := '0' || v_date_digits;
                  END IF;
                  
                  IF length(v_date_digits) = 6 THEN
                    DECLARE
                      v_month text := substring(v_date_digits from 1 for 2);
                      v_day text := substring(v_date_digits from 3 for 2);
                      v_year text := '20' || substring(v_date_digits from 5 for 2);
                      v_date_value date;
                    BEGIN
                      -- Validate date
                      BEGIN
                        v_date_value := make_date(v_year::int, v_month::int, v_day::int);
                        v_purchase_date := v_year || '-' || v_month || '-' || v_day;
                      EXCEPTION WHEN OTHERS THEN
                        v_missing_fields := array_append(v_missing_fields, 'purchase_date');
                      END;
                    END;
                  ELSE
                    v_missing_fields := array_append(v_missing_fields, 'purchase_date');
                  END IF;
                EXCEPTION WHEN OTHERS THEN
                  v_missing_fields := array_append(v_missing_fields, 'purchase_date');
                END;
              ELSE
                v_missing_fields := array_append(v_missing_fields, 'purchase_date');
              END IF;
            END;
          END IF;
        END;
      ELSE
        v_missing_fields := array_append(v_missing_fields, 'product_code');
        v_missing_fields := array_append(v_missing_fields, 'vendor_uid');
        v_missing_fields := array_append(v_missing_fields, 'purchase_date');
      END IF;
      
      -- Remaining lines become notes
      IF array_length(v_lines, 1) > 1 THEN
        DECLARE
          v_note_lines text[] := '{}';
          j int;
        BEGIN
          FOR j IN 2..array_length(v_lines, 1) LOOP
            IF j != v_code_line_idx THEN
              v_note_lines := array_append(v_note_lines, v_lines[j]);
            END IF;
          END LOOP;
          
          IF array_length(v_note_lines, 1) > 0 THEN
            v_notes := trim(array_to_string(v_note_lines, E'\n'));
          END IF;
        END;
      END IF;
      
      -- Multi-line captions typically don't have quantities
      v_missing_fields := array_append(v_missing_fields, 'quantity');
    END;
  ELSE
    -- Single line caption processing
    
    -- Simple cases first
    
    -- Case: Just a quantity like "14x"
    IF v_trimmed_caption ~ '^\d+x$' THEN
      v_quantity := (substring(v_trimmed_caption from '^(\d+)x$'))::int;
      v_quantity_pattern := v_trimmed_caption;
      v_missing_fields := array_cat(v_missing_fields, ARRAY['product_name', 'product_code', 'vendor_uid', 'purchase_date']);
    
    -- Case: Simple product name without code or quantity
    ELSIF position('#' in v_trimmed_caption) = 0 AND position('x' in v_trimmed_caption) = 0 THEN
      v_product_name := v_trimmed_caption;
      v_missing_fields := array_cat(v_missing_fields, ARRAY['product_code', 'vendor_uid', 'purchase_date', 'quantity']);
    
    -- Case: Simple name with quantity like "Product x 2"
    ELSIF position('#' in v_trimmed_caption) = 0 AND v_trimmed_caption ~ 'x\s*\d+$' THEN
      v_product_name := trim(substring(v_trimmed_caption from '^(.+?)\s+x\s*\d+$'));
      v_quantity := (substring(v_trimmed_caption from 'x\s*(\d+)$'))::int;
      v_quantity_pattern := substring(v_trimmed_caption from 'x\s*\d+$');
      v_missing_fields := array_cat(v_missing_fields, ARRAY['product_code', 'vendor_uid', 'purchase_date']);
    
    -- More complex cases
    ELSE
      -- Special case: "Product #N #CODE123456 x 1"
      IF v_trimmed_caption ~ '^.+?\s+#\d+\s+#[A-Za-z]{1,4}\d{5,6}' THEN
        DECLARE
          v_product_part text;
          v_number_part text;
          v_code_part text;
          v_remaining text;
        BEGIN
          v_product_part := substring(v_trimmed_caption from '^(.+?)\s+#\d+\s+#');
          v_number_part := substring(v_trimmed_caption from '\s+(#\d+)\s+#');
          v_code_part := substring(v_trimmed_caption from '#[A-Za-z]{1,4}\d{5,6}');
          v_product_name := trim(v_product_part || ' ' || v_number_part);
          
          -- Extract product code without the # symbol
          v_product_code := substring(v_code_part from '#(.+)');
          
          -- Process vendor and date from code
          v_vendor_uid := upper(substring(v_product_code from '^([A-Za-z]{1,4})'));
          
          IF v_vendor_uid IS NULL THEN
            v_missing_fields := array_append(v_missing_fields, 'vendor_uid');
          END IF;
          
          DECLARE
            v_date_digits text;
          BEGIN
            v_date_digits := substring(v_product_code from '^[A-Za-z]{1,4}(\d{5,6})');
            
            IF v_date_digits IS NOT NULL THEN
              -- Format date
              IF length(v_date_digits) = 5 THEN
                v_date_digits := '0' || v_date_digits;
              END IF;
              
              IF length(v_date_digits) = 6 THEN
                DECLARE
                  v_month text := substring(v_date_digits from 1 for 2);
                  v_day text := substring(v_date_digits from 3 for 2);
                  v_year text := '20' || substring(v_date_digits from 5 for 2);
                  v_date_value date;
                BEGIN
                  -- Validate date
                  BEGIN
                    v_date_value := make_date(v_year::int, v_month::int, v_day::int);
                    v_purchase_date := v_year || '-' || v_month || '-' || v_day;
                  EXCEPTION WHEN OTHERS THEN
                    v_missing_fields := array_append(v_missing_fields, 'purchase_date');
                  END;
                END;
              ELSE
                v_missing_fields := array_append(v_missing_fields, 'purchase_date');
              END IF;
            ELSE
              v_missing_fields := array_append(v_missing_fields, 'purchase_date');
            END IF;
          END;
          
          -- Look for quantity and notes in remaining text
          v_remaining := substring(v_trimmed_caption from v_code_part || '(.+)$');
          
          -- Find quantity
          DECLARE
            v_qty_match text;
          BEGIN
            v_qty_match := substring(v_remaining from 'x\s*(\d+)');
            
            IF v_qty_match IS NOT NULL THEN
              v_quantity := v_qty_match::int;
              v_quantity_pattern := 'x ' || v_qty_match;
            ELSE
              v_missing_fields := array_append(v_missing_fields, 'quantity');
            END IF;
          END;
          
          -- Find notes in parentheses
          v_notes := substring(v_remaining from '\(([^)]+)\)');
        END;
      ELSE
        -- Standard cases
        DECLARE
          v_hash_positions int[];
          v_product_code_position int := 0;
          v_quantity_position int := 0;
          v_reverse_quantity_position int := 0;
          v_notes_position int := 0;
          v_temp_array text[];
          v_vendor_code text;
          v_is_standard_vendor boolean := false;
        BEGIN
          -- Find all hash positions using string_to_array and unnest
          WITH hash_positions AS (
            SELECT 
              (t.position - 1) as pos
            FROM 
              unnest(string_to_array(v_trimmed_caption, NULL)) WITH ORDINALITY t(char, position)
            WHERE 
              t.char = '#'
          )
          SELECT array_agg(pos) INTO v_hash_positions FROM hash_positions;
          
          -- Extract potential product codes
          IF v_hash_positions IS NOT NULL AND array_length(v_hash_positions, 1) > 0 THEN
            FOREACH v_product_code_position IN ARRAY v_hash_positions LOOP
              v_vendor_code := substring(v_trimmed_caption from v_product_code_position + 2); -- +2 to skip the #
              
              -- Check if it matches vendor pattern
              IF v_vendor_code ~ '^[A-Za-z]{1,4}\d{5,6}' THEN
                v_is_standard_vendor := true;
                v_product_code := substring(v_vendor_code from '^([A-Za-z0-9-]+)');
                EXIT;
              END IF;
            END LOOP;
            
            -- If no standard vendor code found, use the first hash code that's not just a number
            IF NOT v_is_standard_vendor AND array_length(v_hash_positions, 1) > 0 THEN
              FOREACH v_product_code_position IN ARRAY v_hash_positions LOOP
                v_vendor_code := substring(v_trimmed_caption from v_product_code_position + 2); -- +2 to skip the #
                
                -- Skip if it's just a number
                IF v_vendor_code !~ '^\d+$' THEN
                  v_product_code := substring(v_vendor_code from '^([A-Za-z0-9-]+)');
                  EXIT;
                END IF;
              END LOOP;
            END IF;
          END IF;
          
          -- Find quantity positions
          v_quantity_position := position('x ' in v_trimmed_caption);
          IF v_quantity_position = 0 THEN
            v_quantity_position := position('x' in v_trimmed_caption);
          END IF;
          
          -- Find reverse quantity (like "2x")
          SELECT position(m[1] in v_trimmed_caption) INTO v_reverse_quantity_position
          FROM regexp_matches(v_trimmed_caption, '(\d+\s*x)(?!\w)', 'g') m
          LIMIT 1;
          
          -- Find notes positions
          v_notes_position := position('(' in v_trimmed_caption);
          
          -- Extract product name
          IF v_product_code_position > 0 THEN
            -- Default: everything before the product code
            v_product_name := trim(substring(v_trimmed_caption from 1 for v_product_code_position));
            
            -- Adjust if quantity or notes come first
            IF v_quantity_position > 0 AND v_quantity_position < v_product_code_position THEN
              v_product_name := trim(substring(v_trimmed_caption from 1 for v_quantity_position - 1));
            END IF;
            
            IF v_notes_position > 0 AND v_notes_position < v_product_code_position THEN
              v_product_name := trim(substring(v_trimmed_caption from 1 for v_notes_position - 1));
            END IF;
            
            -- Process product code components
            -- Extract vendor UID
            v_vendor_uid := upper(substring(v_product_code from '^([A-Za-z]{1,4})'));
            
            IF v_vendor_uid IS NULL THEN
              v_missing_fields := array_append(v_missing_fields, 'vendor_uid');
            END IF;
            
            -- Extract purchase date
            DECLARE
              v_date_digits text;
            BEGIN
              v_date_digits := substring(v_product_code from '^[A-Za-z]{1,4}(\d{5,6})');
              
              IF v_date_digits IS NOT NULL THEN
                -- Format date
                IF length(v_date_digits) = 5 THEN
                  v_date_digits := '0' || v_date_digits;
                END IF;
                
                IF length(v_date_digits) = 6 THEN
                  DECLARE
                    v_month text := substring(v_date_digits from 1 for 2);
                    v_day text := substring(v_date_digits from 3 for 2);
                    v_year text := '20' || substring(v_date_digits from 5 for 2);
                    v_date_value date;
                  BEGIN
                    -- Validate date
                    BEGIN
                      v_date_value := make_date(v_year::int, v_month::int, v_day::int);
                      v_purchase_date := v_year || '-' || v_month || '-' || v_day;
                    EXCEPTION WHEN OTHERS THEN
                      v_missing_fields := array_append(v_missing_fields, 'purchase_date');
                    END;
                  END;
                ELSE
                  v_missing_fields := array_append(v_missing_fields, 'purchase_date');
                END IF;
              ELSE
                v_missing_fields := array_append(v_missing_fields, 'purchase_date');
              END IF;
            END;
          ELSE
            -- No product code
            v_missing_fields := array_cat(v_missing_fields, ARRAY['product_code', 'vendor_uid', 'purchase_date']);
            
            -- Extract product name based on other delimiters
            IF v_quantity_position > 0 THEN
              v_product_name := trim(substring(v_trimmed_caption from 1 for v_quantity_position - 1));
            ELSIF v_reverse_quantity_position > 0 THEN
              v_product_name := trim(substring(v_trimmed_caption from 1 for v_reverse_quantity_position - 1));
            ELSIF v_notes_position > 0 THEN
              v_product_name := trim(substring(v_trimmed_caption from 1 for v_notes_position - 1));
            ELSE
              v_product_name := v_trimmed_caption;
            END IF;
          END IF;
          
          -- Extract quantity
          IF v_quantity_position > 0 THEN
            v_quantity := (substring(v_trimmed_caption from 'x\s*(\d+)'))::int;
            v_quantity_pattern := substring(v_trimmed_caption from 'x\s*\d+');
          ELSIF v_reverse_quantity_position > 0 THEN
            v_quantity := (substring(v_trimmed_caption from '(\d+)\s*x'))::int;
            v_quantity_pattern := substring(v_trimmed_caption from '\d+\s*x');
          ELSE
            v_missing_fields := array_append(v_missing_fields, 'quantity');
          END IF;
          
          -- Extract notes
          v_notes := substring(v_trimmed_caption from '\(([^)]+)\)');
        END;
      END IF;
    END IF;
  END IF;
  
  -- Check for missing product name
  IF v_product_name IS NULL OR v_product_name = '' THEN
    v_missing_fields := array_append(v_missing_fields, 'product_name');
  END IF;
  
  -- Update the result object with our extracted values
  v_partial_success := array_length(v_missing_fields, 1) > 0;
  
  v_result := jsonb_set(v_result, '{product_name}', to_jsonb(v_product_name));
  v_result := jsonb_set(v_result, '{product_code}', to_jsonb(v_product_code));
  v_result := jsonb_set(v_result, '{vendor_uid}', COALESCE(to_jsonb(v_vendor_uid), 'null'::jsonb));
  v_result := jsonb_set(v_result, '{purchase_date}', COALESCE(to_jsonb(v_purchase_date), 'null'::jsonb));
  v_result := jsonb_set(v_result, '{quantity}', COALESCE(to_jsonb(v_quantity), 'null'::jsonb));
  v_result := jsonb_set(v_result, '{notes}', to_jsonb(COALESCE(v_notes, '')));
  
  -- Set metadata
  v_result := jsonb_set(v_result, '{parsing_metadata,partial_success}', to_jsonb(v_partial_success));
  
  IF v_partial_success THEN
    v_result := jsonb_set(v_result, '{parsing_metadata,missing_fields}', to_jsonb(v_missing_fields));
  END IF;
  
  IF v_quantity_pattern IS NOT NULL THEN
    v_result := jsonb_set(v_result, '{parsing_metadata,quantity_pattern}', to_jsonb(v_quantity_pattern));
  END IF;
  
  RETURN v_result;
END;
$function$
","jsonb","p_caption text"
"xdelo_process_caption_trigger","CREATE OR REPLACE FUNCTION public.xdelo_process_caption_trigger()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  -- Call the workflow function with the NEW record's id and correlation_id as text
  PERFORM public.xdelo_process_caption_workflow(NEW.id, NEW.correlation_id::text);
  RETURN NEW;
END;
$function$
","trigger",""
"xdelo_process_caption_workflow","CREATE OR REPLACE FUNCTION public.xdelo_process_caption_workflow(p_message_id uuid, p_correlation_id text DEFAULT NULL::text, p_force boolean DEFAULT false)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_message messages;
  v_caption TEXT;
  v_media_group_id TEXT;
  v_analyzed_content JSONB;
  v_correlation_uuid uuid;
BEGIN
  -- Convert correlation_id to UUID if provided, otherwise generate new one
  v_correlation_uuid := CASE 
    WHEN p_correlation_id IS NOT NULL THEN 
      CASE 
        WHEN p_correlation_id::uuid IS NOT NULL THEN p_correlation_id::uuid
        ELSE gen_random_uuid()
      END
    ELSE gen_random_uuid()
  END;

  -- Get the message
  SELECT * INTO v_message FROM messages WHERE id = p_message_id;
  
  IF v_message IS NULL THEN
    RETURN jsonb_build_object(
      'success', FALSE,
      'message', 'Message not found',
      'message_id', p_message_id
    );
  END IF;
  
  -- Check if already processed and force not specified
  IF v_message.processing_state = 'completed' AND NOT p_force THEN
    RETURN jsonb_build_object(
      'success', FALSE, 
      'message', 'Message already processed',
      'message_id', p_message_id
    );
  END IF;
  
  -- Update to processing state
  UPDATE messages
  SET processing_state = 'processing',
      processing_started_at = NOW(),
      updated_at = NOW()
  WHERE id = p_message_id;
  
  -- Log the processing start
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    correlation_id,
    metadata,
    event_timestamp
  ) VALUES (
    'message_processing_started',
    p_message_id,
    v_correlation_uuid::text,
    jsonb_build_object(
      'processor', 'xdelo_process_caption_workflow',
      'start_time', NOW(),
      'caption_length', length(v_message.caption),
      'force', p_force
    ),
    NOW()
  );
  
  v_caption := v_message.caption;
  v_media_group_id := v_message.media_group_id;
  
  -- Check if caption exists
  IF v_caption IS NULL OR v_caption = '' THEN
    -- No caption to process, mark as completed if not part of a media group
    IF v_media_group_id IS NULL THEN
      UPDATE messages
      SET processing_state = 'completed',
          processing_completed_at = NOW(),
          analyzed_content = jsonb_build_object(
            'caption', '',
            'parsing_metadata', jsonb_build_object(
              'method', 'empty_caption',
              'timestamp', NOW()
            )
          ),
          updated_at = NOW()
      WHERE id = p_message_id;
      
      RETURN jsonb_build_object(
        'success', TRUE,
        'message', 'No caption to process, marked as completed',
        'message_id', p_message_id
      );
    ELSE
      -- For media group messages without caption, check if we can sync from another message
      RETURN xdelo_check_media_group_content(
        p_media_group_id, 
        p_message_id, 
        v_correlation_uuid::text
      );
    END IF;
  END IF;
  
  -- We have a caption, mark the message for edge function processing
  UPDATE messages
  SET processing_state = 'pending',
      is_original_caption = CASE WHEN v_media_group_id IS NOT NULL THEN true ELSE is_original_caption END,
      updated_at = NOW()
  WHERE id = p_message_id;
  
  -- Immediately trigger caption processing by creating an audit log entry
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    correlation_id,
    metadata,
    event_timestamp
  ) VALUES (
    'caption_ready_for_processing',
    p_message_id,
    v_correlation_uuid::text,
    jsonb_build_object(
      'media_group_id', v_media_group_id,
      'caption', v_caption,
      'immediate_processing', TRUE
    ),
    NOW()
  );
  
  RETURN jsonb_build_object(
    'success', TRUE,
    'message_id', p_message_id,
    'media_group_id', v_media_group_id,
    'is_media_group', v_media_group_id IS NOT NULL,
    'caption', v_caption,
    'correlation_id', v_correlation_uuid,
    'ready_for_processing', TRUE,
    'immediate_trigger', TRUE
  );
EXCEPTION
  WHEN OTHERS THEN
    -- Update to error state
    UPDATE messages
    SET processing_state = 'error',
        error_message = SQLERRM,
        updated_at = NOW()
    WHERE id = p_message_id;
    
    -- Log the error
    INSERT INTO unified_audit_logs (
      event_type,
      entity_id,
      correlation_id,
      error_message,
      metadata,
      event_timestamp
    ) VALUES (
      'message_processing_error',
      p_message_id,
      v_correlation_uuid::text,
      SQLERRM,
      jsonb_build_object(
        'processor', 'xdelo_process_caption_workflow',
        'error_time', NOW()
      ),
      NOW()
    );
    
    RETURN jsonb_build_object(
      'success', FALSE,
      'message_id', p_message_id,
      'error', SQLERRM
    );
END;
$function$
","jsonb","p_message_id uuid, p_correlation_id text DEFAULT NULL::text, p_force boolean DEFAULT false"
"xdelo_product_sku_generate","CREATE OR REPLACE FUNCTION public.xdelo_product_sku_generate()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.product_name IS NOT NULL AND NEW.product_code IS NOT NULL THEN
        NEW.product_sku := NEW.product_name || ' #' || NEW.product_code;
    ELSE
        NEW.product_sku := NULL; -- Set to NULL if either value is NULL
    END IF;
    RETURN NEW;
END;
$function$
","trigger",""
"xdelo_purchase_order_uid","CREATE OR REPLACE FUNCTION public.xdelo_purchase_order_uid()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.product_code IS NOT NULL THEN
        NEW.purchase_order_uid := 'PO#' || NEW.product_code;
    END IF;
    RETURN NEW;
END;
$function$
","trigger",""
"xdelo_repair_file","CREATE OR REPLACE FUNCTION public.xdelo_repair_file(p_message_id uuid, p_action text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    CASE p_action
    WHEN 'fix_mime_type' THEN
        RETURN xdelo_fix_mime_types(p_message_id);
    WHEN 'fix_storage_path' THEN
        RETURN xdelo_standardize_storage_path(p_message_id);
    WHEN 'repair_media' THEN
        RETURN xdelo_file_repair(p_message_id);
    ELSE
        RETURN jsonb_build_object('error', 'Invalid action');
    END CASE;
END;
$function$
","jsonb","p_message_id uuid, p_action text"
"xdelo_repair_media_group_syncs","CREATE OR REPLACE FUNCTION public.xdelo_repair_media_group_syncs()
 RETURNS TABLE(media_group_id text, source_message_id uuid, updated_count integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_group record;
  v_source_message_id uuid;
  v_result jsonb;
BEGIN
  -- Find media groups that have sync issues
  FOR v_group IN 
    SELECT 
      mg.media_group_id
    FROM (
      SELECT 
        media_group_id,
        COUNT(*) as total_count,
        COUNT(*) FILTER (WHERE analyzed_content IS NULL) as missing_content_count,
        COUNT(*) FILTER (WHERE group_caption_synced = false) as unsynced_count
      FROM 
        messages
      WHERE 
        media_group_id IS NOT NULL
        AND deleted_from_telegram = false
      GROUP BY 
        media_group_id
    ) mg
    WHERE 
      mg.missing_content_count > 0
      OR mg.unsynced_count > 0
    LIMIT 100
  LOOP
    -- Find a suitable caption message
    v_source_message_id := xdelo_find_caption_message(v_group.media_group_id);
    
    IF v_source_message_id IS NOT NULL THEN
      -- Sync the group using our new function
      v_result := xdelo_sync_media_group_content(
        v_source_message_id,
        v_group.media_group_id,
        'repair_' || gen_random_uuid()::text,
        true,
        true  -- Always sync edit history during repairs
      );
      
      IF (v_result->>'success')::boolean THEN
        media_group_id := v_group.media_group_id;
        source_message_id := v_source_message_id;
        updated_count := (v_result->>'updated_count')::integer;
        RETURN NEXT;
      END IF;
    END IF;
  END LOOP;
END;
$function$
","TABLE(media_group_id text, source_message_id uuid, updated_count integer)",""
"xdelo_repair_message_relationships","CREATE OR REPLACE FUNCTION public.xdelo_repair_message_relationships()
 RETURNS TABLE(media_group_id text, caption_message_id uuid, updated_count integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_group record;
    v_caption_message_id uuid;
    v_updated_count integer;
BEGIN
    -- Find media groups where messages don't have message_caption_id set
    FOR v_group IN 
        SELECT DISTINCT m.media_group_id
        FROM messages m
        WHERE m.media_group_id IS NOT NULL
        AND EXISTS (
            SELECT 1 FROM messages m2 
            WHERE m2.media_group_id = m.media_group_id 
            AND m2.message_caption_id IS NULL
        )
        AND EXISTS (
            SELECT 1 FROM messages m3 
            WHERE m3.media_group_id = m.media_group_id 
            AND m3.is_original_caption = true
        )
    LOOP
        -- Find the caption message for this group
        SELECT id INTO v_caption_message_id
        FROM messages
        WHERE media_group_id = v_group.media_group_id
        AND is_original_caption = true
        LIMIT 1;
        
        IF v_caption_message_id IS NOT NULL THEN
            -- Update all messages in the group that don't have message_caption_id set
            UPDATE messages
            SET message_caption_id = v_caption_message_id
            WHERE media_group_id = v_group.media_group_id
            AND message_caption_id IS NULL
            AND id != v_caption_message_id;
            
            GET DIAGNOSTICS v_updated_count = ROW_COUNT;
            
            -- Return the results
            media_group_id := v_group.media_group_id;
            caption_message_id := v_caption_message_id;
            updated_count := v_updated_count;
            RETURN NEXT;
        END IF;
    END LOOP;
END;
$function$
","TABLE(media_group_id text, caption_message_id uuid, updated_count integer)",""
"xdelo_set_file_id_expiration","CREATE OR REPLACE FUNCTION public.xdelo_set_file_id_expiration()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    SET search_path = 'public';

    -- Only set expiration if file_id exists and expiration isn't already set
    IF NEW.file_id IS NOT NULL AND NEW.file_id_expires_at IS NULL THEN
        NEW.file_id_expires_at := NOW() + INTERVAL '24 hours';
    END IF;

    -- Keep track of original file_id if it changes
    IF (TG_OP = 'UPDATE' AND OLD.file_id != NEW.file_id AND NEW.file_id IS NOT NULL) THEN
        NEW.original_file_id := COALESCE(OLD.original_file_id, OLD.file_id);
    END IF;

    RETURN NEW;
END;
$function$
","trigger",""
"xdelo_set_message_processing","CREATE OR REPLACE FUNCTION public.xdelo_set_message_processing(p_message_id uuid, p_correlation_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE messages
  SET 
    processing_state = 'processing',
    processing_started_at = NOW(),
    processing_correlation_id = p_correlation_id
  WHERE id = p_message_id;
  
  -- Log the processing start
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    correlation_id,
    metadata,
    event_timestamp
  ) VALUES (
    'message_processing_started',
    p_message_id,
    p_correlation_id::text,
    jsonb_build_object(
      'processor', 'direct-caption-processor',
      'start_time', NOW()
    ),
    NOW()
  );
END;
$function$
","void","p_message_id uuid, p_correlation_id uuid"
"xdelo_set_public_url","CREATE OR REPLACE FUNCTION public.xdelo_set_public_url()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF NEW.storage_path IS NOT NULL AND NEW.storage_path != '' THEN
    NEW.public_url := 'https://xjhhehxcxkiumnwbirel.supabase.co/storage/v1/object/public/telegram-media/' || NEW.storage_path;
    NEW.storage_path_standardized := TRUE;
  END IF;
  RETURN NEW;
END;
$function$
","trigger",""
"xdelo_standardize_file_extension","CREATE OR REPLACE FUNCTION public.xdelo_standardize_file_extension(p_mime_type text)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
  v_extension text;
BEGIN
  -- Map MIME types to standard extensions
  CASE 
    WHEN p_mime_type LIKE 'image/jpeg' OR p_mime_type LIKE 'image/jpg' THEN
      v_extension := 'jpg';
    WHEN p_mime_type LIKE 'image/png' THEN
      v_extension := 'png';
    WHEN p_mime_type LIKE 'image/gif' THEN
      v_extension := 'gif';
    WHEN p_mime_type LIKE 'image/webp' THEN
      v_extension := 'webp';
    WHEN p_mime_type LIKE 'image/svg+xml' THEN
      v_extension := 'svg';
    WHEN p_mime_type LIKE 'video/mp4' THEN
      v_extension := 'mp4';
    WHEN p_mime_type LIKE 'video/quicktime' THEN
      v_extension := 'mov';
    WHEN p_mime_type LIKE 'video/x-matroska' THEN
      v_extension := 'mkv';
    WHEN p_mime_type LIKE 'video/webm' THEN
      v_extension := 'webm';
    WHEN p_mime_type LIKE 'audio/mpeg' THEN
      v_extension := 'mp3';
    WHEN p_mime_type LIKE 'audio/wav' THEN
      v_extension := 'wav';
    WHEN p_mime_type LIKE 'audio/ogg' THEN
      v_extension := 'ogg';
    WHEN p_mime_type LIKE 'application/pdf' THEN
      v_extension := 'pdf';
    WHEN p_mime_type LIKE 'application/msword' THEN
      v_extension := 'doc';
    WHEN p_mime_type LIKE 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' THEN
      v_extension := 'docx';
    WHEN p_mime_type LIKE 'application/vnd.ms-excel' THEN
      v_extension := 'xls';
    WHEN p_mime_type LIKE 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' THEN
      v_extension := 'xlsx';
    WHEN p_mime_type LIKE 'text/plain' THEN
      v_extension := 'txt';
    WHEN p_mime_type LIKE 'application/zip' THEN
      v_extension := 'zip';
    WHEN p_mime_type LIKE 'application/x-tgsticker' THEN
      v_extension := 'tgs';
    ELSE
      -- Extract the subtype from MIME type (part after /)
      BEGIN
        v_extension := split_part(p_mime_type, '/', 2);
        -- Remove parameters if any (e.g., ";charset=utf-8")
        v_extension := split_part(v_extension, ';', 1);
        -- If extension is empty or same as full mime type, default to bin
        IF v_extension = '' OR v_extension = p_mime_type THEN
          v_extension := 'bin';
        END IF;
      EXCEPTION WHEN OTHERS THEN
        v_extension := 'bin';
      END;
  END CASE;
  
  RETURN v_extension;
END;
$function$
","text","p_mime_type text"
"xdelo_standardize_storage_path","CREATE OR REPLACE FUNCTION public.xdelo_standardize_storage_path(p_file_unique_id text, p_mime_type text DEFAULT 'image/jpeg'::text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_extension text;
  v_storage_path text;
BEGIN
  -- Use the standardize file extension function
  v_extension := public.xdelo_standardize_file_extension(p_mime_type);
  
  -- Check for existing storage path if it's an octet-stream
  IF p_mime_type = 'application/octet-stream' THEN
    BEGIN
      SELECT storage_path INTO v_storage_path
      FROM messages
      WHERE file_unique_id = p_file_unique_id
      AND storage_path IS NOT NULL
      AND storage_path != ''
      LIMIT 1;
      
      IF v_storage_path IS NOT NULL THEN
        RETURN v_storage_path;
      END IF;
    EXCEPTION WHEN OTHERS THEN
      -- Continue with default
    END;
  END IF;
  
  -- Return standardized storage path
  RETURN p_file_unique_id || '.' || v_extension;
END;
$function$
","text","p_file_unique_id text, p_mime_type text DEFAULT 'image/jpeg'::text"
"xdelo_sync_forward_media","CREATE OR REPLACE FUNCTION public.xdelo_sync_forward_media(p_original_message_id uuid, p_forward_message_id uuid)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_original_message messages;
BEGIN
  -- Get the original message
  SELECT * INTO v_original_message
  FROM messages
  WHERE id = p_original_message_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Original message not found';
  END IF;

  -- Update the forwarded message with the original message's media info
  UPDATE messages
  SET 
    file_id = v_original_message.file_id,
    file_unique_id = v_original_message.file_unique_id,
    public_url = v_original_message.public_url,
    mime_type = v_original_message.mime_type,
    file_size = v_original_message.file_size,
    width = v_original_message.width,
    height = v_original_message.height,
    duration = v_original_message.duration,
    updated_at = NOW()
  WHERE 
    id = p_forward_message_id;

  -- Log the sync operation
  PERFORM xdelo_log_event(
    'forward_media_synced'::audit_event_type,
    p_forward_message_id,
    NULL,
    NULL,
    NULL,
    jsonb_build_object(
      'original_message_id', p_original_message_id,
      'file_unique_id', v_original_message.file_unique_id
    ),
    jsonb_build_object(
      'sync_source', 'forward_sync',
      'public_url', v_original_message.public_url
    ),
    NULL
  );
END;
$function$
","void","p_original_message_id uuid, p_forward_message_id uuid"
"xdelo_sync_media_group_content","CREATE OR REPLACE FUNCTION public.xdelo_sync_media_group_content(p_source_message_id text, p_media_group_id text, p_correlation_id text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_source_message RECORD;
BEGIN
  SELECT id, analyzed_content, caption
  INTO v_source_message
  FROM public.messages
  WHERE id = p_source_message_id;
  
  IF v_source_message.analyzed_content IS NULL THEN
    PERFORM xdelo_log_message_operation(
      'sync_error',
      p_source_message_id,
      jsonb_build_object(
        'media_group_id', p_media_group_id,
        'error', 'Source message has no analyzed content'
      ),
      'Source message has no analyzed content'
    );
    RETURN;
  END IF;
  
  UPDATE public.messages
  SET analyzed_content = v_source_message.analyzed_content,
      group_caption_synced = true,
      processing_state = 'completed',
      processing_completed_at = NOW(),
      message_caption_id = p_source_message_id
  WHERE media_group_id = p_media_group_id
    AND id != p_source_message_id;
  
  PERFORM xdelo_log_message_operation(
    'media_group_synced',
    p_source_message_id,
    jsonb_build_object(
      'media_group_id', p_media_group_id,
      'correlation_id', p_correlation_id
    )
  );
END;
$function$
","void","p_source_message_id text, p_media_group_id text, p_correlation_id text DEFAULT NULL::text"
"xdelo_sync_media_group_content","CREATE OR REPLACE FUNCTION public.xdelo_sync_media_group_content(p_source_message_id uuid, p_media_group_id text, p_correlation_id text DEFAULT NULL::text, p_force_sync boolean DEFAULT false, p_sync_edit_history boolean DEFAULT false)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_source_message messages;
  v_result JSONB;
  v_updated_count INTEGER := 0;
  v_error TEXT;
  v_lock_acquired BOOLEAN;
BEGIN
  -- Acquire advisory lock on media group to prevent concurrent syncs
  -- We use hashtext to convert the media_group_id string to a bigint
  v_lock_acquired := pg_try_advisory_xact_lock(hashtext(p_media_group_id));
  
  IF NOT v_lock_acquired THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Could not acquire lock on media group, another sync operation is in progress',
      'media_group_id', p_media_group_id
    );
  END IF;

  -- Input validation
  IF p_source_message_id IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Source message ID cannot be null',
      'source_message_id', p_source_message_id
    );
  END IF;
  
  IF p_media_group_id IS NULL OR p_media_group_id = '' THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Media group ID cannot be null or empty',
      'media_group_id', p_media_group_id
    );
  END IF;

  -- Get the source message with analyzed content
  SELECT * INTO v_source_message
  FROM messages
  WHERE id = p_source_message_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Source message not found',
      'message_id', p_source_message_id
    );
  END IF;
  
  -- Verify source message has analyzed content
  IF v_source_message.analyzed_content IS NULL THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Source message has no analyzed content',
      'message_id', p_source_message_id
    );
  END IF;
  
  -- Mark source message as the original caption holder
  UPDATE messages
  SET 
    is_original_caption = true,
    group_caption_synced = true,
    updated_at = NOW()
  WHERE id = p_source_message_id;
  
  -- Update all other messages in the group with the analyzed content - BATCH UPDATE
  WITH updated_messages AS (
    UPDATE messages
    SET 
      analyzed_content = v_source_message.analyzed_content,
      processing_state = 'completed',
      group_caption_synced = true,
      message_caption_id = p_source_message_id,
      is_original_caption = false,
      processing_completed_at = COALESCE(processing_completed_at, NOW()),
      updated_at = NOW(),
      -- Only sync edit history if specifically requested
      old_analyzed_content = CASE 
        WHEN p_sync_edit_history AND v_source_message.old_analyzed_content IS NOT NULL 
        THEN v_source_message.old_analyzed_content
        ELSE old_analyzed_content
      END
    WHERE 
      media_group_id = p_media_group_id 
      AND id != p_source_message_id
      AND (p_force_sync = true OR group_caption_synced = false OR analyzed_content IS NULL)
    RETURNING id
  )
  SELECT COUNT(*) INTO v_updated_count FROM updated_messages;
  
  -- Update media group metadata for all messages in the group
  WITH group_stats AS (
    SELECT 
      COUNT(*) as message_count,
      MIN(created_at) as first_message_time,
      MAX(created_at) as last_message_time
    FROM messages
    WHERE media_group_id = p_media_group_id
  )
  UPDATE messages m
  SET
    group_message_count = gs.message_count,
    group_first_message_time = gs.first_message_time,
    group_last_message_time = gs.last_message_time,
    updated_at = NOW()
  FROM group_stats gs
  WHERE m.media_group_id = p_media_group_id;
  
  -- Log the sync operation
  INSERT INTO unified_audit_logs (
    event_type,
    entity_id,
    metadata,
    correlation_id,
    event_timestamp
  ) VALUES (
    'media_group_content_synced',
    p_source_message_id,
    jsonb_build_object(
      'media_group_id', p_media_group_id,
      'source_message_id', p_source_message_id,
      'updated_messages_count', v_updated_count,
      'operation', 'sync_group',
      'force_sync', p_force_sync,
      'sync_edit_history', p_sync_edit_history
    ),
    p_correlation_id,
    NOW()
  );
  
  RETURN jsonb_build_object(
    'success', true,
    'media_group_id', p_media_group_id,
    'source_message_id', p_source_message_id, 
    'updated_count', v_updated_count,
    'correlation_id', p_correlation_id,
    'force_sync', p_force_sync,
    'sync_edit_history', p_sync_edit_history
  );
EXCEPTION
  WHEN OTHERS THEN
    v_error := SQLERRM;
    
    -- Log the error
    INSERT INTO unified_audit_logs (
      event_type,
      entity_id,
      error_message,
      metadata,
      correlation_id,
      event_timestamp
    ) VALUES (
      'media_group_sync_error',
      p_source_message_id,
      v_error,
      jsonb_build_object(
        'media_group_id', p_media_group_id,
        'operation', 'sync_group',
        'force_sync', p_force_sync,
        'sync_edit_history', p_sync_edit_history
      ),
      p_correlation_id,
      NOW()
    );
    
    RETURN jsonb_build_object(
      'success', false,
      'error', v_error,
      'media_group_id', p_media_group_id,
      'source_message_id', p_source_message_id
    );
END;
$function$
","jsonb","p_source_message_id uuid, p_media_group_id text, p_correlation_id text DEFAULT NULL::text, p_force_sync boolean DEFAULT false, p_sync_edit_history boolean DEFAULT false"
"xdelo_sync_media_group_history","CREATE OR REPLACE FUNCTION public.xdelo_sync_media_group_history()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- When old_analyzed_content changes, sync to media group
  IF NEW.old_analyzed_content IS DISTINCT FROM OLD.old_analyzed_content 
     AND NEW.media_group_id IS NOT NULL THEN
    
    UPDATE messages
    SET old_analyzed_content = NEW.old_analyzed_content,
        edit_history = NEW.edit_history,
        updated_at = NOW()
    WHERE media_group_id = NEW.media_group_id 
    AND id != NEW.id;
    
    -- Log the sync operation
    PERFORM xdelo_log_event(
      'media_group_history_synced'::audit_event_type,
      NEW.id,
      NEW.telegram_message_id,
      NEW.chat_id,
      jsonb_build_object('previous_state', OLD.old_analyzed_content),
      jsonb_build_object('new_state', NEW.old_analyzed_content),
      jsonb_build_object(
        'media_group_id', NEW.media_group_id,
        'sync_type', 'history'
      ),
      NEW.correlation_id
    );
  END IF;
  RETURN NEW;
END;
$function$
","trigger",""
"xdelo_update_message_processing_state","CREATE OR REPLACE FUNCTION public.xdelo_update_message_processing_state(p_message_id uuid, p_state text, p_error text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE messages
  SET
    processing_state = p_state,
    error_message = p_error,
    last_error_at = CASE WHEN p_error IS NOT NULL THEN NOW() END,
    updated_at = NOW()
  WHERE id = p_message_id;
END;
$function$
","void","p_message_id uuid, p_state text, p_error text DEFAULT NULL::text"
"xdelo_update_message_with_analyzed_content","CREATE OR REPLACE FUNCTION public.xdelo_update_message_with_analyzed_content(p_message_id uuid, p_analyzed_content jsonb, p_correlation_id text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_message messages;
    v_media_group_id text;
    v_result jsonb;
BEGIN
    SET search_path = 'public';

    -- Get message data
    SELECT * INTO v_message
    FROM messages
    WHERE id = p_message_id
    FOR UPDATE; -- Lock the row to prevent concurrent updates

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Message not found: %', p_message_id;
    END IF;

    -- Store current media_group_id for later sync
    v_media_group_id := v_message.media_group_id;

    -- Update the message
    UPDATE messages
    SET 
        analyzed_content = p_analyzed_content,
        processing_state = 'completed',
        processing_completed_at = NOW(),
        is_original_caption = true,
        group_caption_synced = false, -- Force sync with media group later
        updated_at = NOW()
    WHERE id = p_message_id
    RETURNING * INTO v_message;

    -- Log the update
    INSERT INTO unified_audit_logs (
        event_type,
        entity_id,
        correlation_id,
        metadata,
        event_timestamp
    ) VALUES (
        'message_content_updated',
        p_message_id,
        p_correlation_id,
        jsonb_build_object(
            'media_group_id', v_media_group_id,
            'has_caption', v_message.caption IS NOT NULL,
            'operation', 'atomic_update'
        ),
        NOW()
    );

    -- Sync with media group
    IF v_media_group_id IS NOT NULL THEN
        v_result := xdelo_sync_media_group_content(
            p_message_id,
            v_media_group_id,
            p_correlation_id,
            true, -- Force sync
            true  -- Sync edit history
        );
    ELSE
        v_result := jsonb_build_object(
            'success', true,
            'message', 'Message updated, no media group to sync',
            'message_id', p_message_id
        );
    END IF;

    RETURN v_result;
END;
$function$
","jsonb","p_message_id uuid, p_analyzed_content jsonb, p_correlation_id text DEFAULT NULL::text"
"xdelo_update_message_with_analyzed_content","CREATE OR REPLACE FUNCTION public.xdelo_update_message_with_analyzed_content(p_message_id uuid, p_analyzed_content jsonb, p_processing_state text DEFAULT 'completed'::text, p_is_edit boolean DEFAULT false)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_message messages;
    v_old_content jsonb[] := ARRAY[]::jsonb[];
    v_result jsonb;
BEGIN
    -- Get the current message state
    SELECT * INTO v_message FROM messages WHERE id = p_message_id;
    
    IF NOT FOUND THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Message not found',
            'message_id', p_message_id
        );
    END IF;
    
    -- Prepare old content for edits
    IF p_is_edit AND v_message.analyzed_content IS NOT NULL THEN
        v_old_content := COALESCE(v_message.old_analyzed_content, ARRAY[]::jsonb[]);
        v_old_content := array_append(v_old_content, v_message.analyzed_content);
    END IF;
    
    -- Update the message
    UPDATE messages
    SET 
        analyzed_content = p_analyzed_content,
        processing_state = p_processing_state::processing_state,
        processing_completed_at = NOW(),
        old_analyzed_content = CASE WHEN p_is_edit THEN v_old_content ELSE old_analyzed_content END,
        -- For media groups, mark as original caption
        is_original_caption = CASE WHEN v_message.media_group_id IS NOT NULL THEN true ELSE is_original_caption END,
        group_caption_synced = true,
        updated_at = NOW()
    WHERE id = p_message_id;
    
    v_result := jsonb_build_object(
        'success', true,
        'message_id', p_message_id,
        'processing_state', p_processing_state,
        'is_edit', p_is_edit
    );
    
    -- If media group present, initiate sync
    IF v_message.media_group_id IS NOT NULL THEN
        v_result := jsonb_set(
            v_result,
            '{media_group_sync}',
            xdelo_sync_media_group_content(
                p_message_id,
                v_message.media_group_id,
                gen_random_uuid()::text,
                true,  -- force_sync
                p_is_edit  -- sync_edit_history for edits
            )
        );
    END IF;
    
    RETURN v_result;
END;
$function$
","jsonb","p_message_id uuid, p_analyzed_content jsonb, p_processing_state text DEFAULT 'completed'::text, p_is_edit boolean DEFAULT false"
"xdelo_update_other_message_url","CREATE OR REPLACE FUNCTION public.xdelo_update_other_message_url()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Update message_url using the construct function
    NEW.message_url := xdelo_construct_telegram_message_url(
        COALESCE(NEW.chat_type::telegram_chat_type, 'unknown'::telegram_chat_type),
        NEW.chat_id,
        NEW.id::uuid
    );
    
    RETURN NEW;
END;
$function$
","trigger",""
"xdelo_update_other_message_url_from_data","CREATE OR REPLACE FUNCTION public.xdelo_update_other_message_url_from_data()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Update message_url using the telegram_data if available
  IF NEW.telegram_data IS NOT NULL AND (NEW.message_url IS NULL OR NEW.message_url = '') THEN
    NEW.message_url := xdelo_construct_message_url_from_data(NEW.telegram_data);
  END IF;
  
  RETURN NEW;
END;
$function$
","trigger",""
"xdelo_update_product_matching_config","CREATE OR REPLACE FUNCTION public.xdelo_update_product_matching_config(p_config jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_similarity_threshold FLOAT;
  v_partial_match_enabled BOOLEAN;
  v_partial_match_min_length INTEGER;
  v_partial_match_date_format TEXT;
  v_weight_name FLOAT;
  v_weight_vendor FLOAT;
  v_weight_purchase_date FLOAT;
  v_result JSONB;
  v_id UUID;
BEGIN
  -- Extract values from input JSON
  v_similarity_threshold := (p_config->>'similarityThreshold')::FLOAT;
  v_partial_match_enabled := (p_config->'partialMatch'->>'enabled')::BOOLEAN;
  v_partial_match_min_length := (p_config->'partialMatch'->>'minLength')::INTEGER;
  v_partial_match_date_format := p_config->'partialMatch'->>'dateFormat';
  v_weight_name := (p_config->'weightedScoring'->>'name')::FLOAT;
  v_weight_vendor := (p_config->'weightedScoring'->>'vendor')::FLOAT;
  v_weight_purchase_date := (p_config->'weightedScoring'->>'purchaseDate')::FLOAT;
  
  -- Get existing config ID if it exists
  SELECT id INTO v_id FROM product_matching_config ORDER BY created_at DESC LIMIT 1;
  
  -- Insert or update configuration
  IF v_id IS NULL THEN
    -- Insert new config
    INSERT INTO product_matching_config (
      similarity_threshold,
      partial_match_enabled,
      partial_match_min_length,
      partial_match_date_format,
      weight_name,
      weight_vendor,
      weight_purchase_date
    ) VALUES (
      COALESCE(v_similarity_threshold, 0.7),
      COALESCE(v_partial_match_enabled, true),
      COALESCE(v_partial_match_min_length, 2),
      COALESCE(v_partial_match_date_format, 'YYYY-MM-DD'),
      COALESCE(v_weight_name, 0.4),
      COALESCE(v_weight_vendor, 0.3),
      COALESCE(v_weight_purchase_date, 0.3)
    ) RETURNING id INTO v_id;
  ELSE
    -- Update existing config
    UPDATE product_matching_config
    SET 
      similarity_threshold = COALESCE(v_similarity_threshold, similarity_threshold),
      partial_match_enabled = COALESCE(v_partial_match_enabled, partial_match_enabled),
      partial_match_min_length = COALESCE(v_partial_match_min_length, partial_match_min_length),
      partial_match_date_format = COALESCE(v_partial_match_date_format, partial_match_date_format),
      weight_name = COALESCE(v_weight_name, weight_name),
      weight_vendor = COALESCE(v_weight_vendor, weight_vendor),
      weight_purchase_date = COALESCE(v_weight_purchase_date, weight_purchase_date),
      updated_at = now()
    WHERE id = v_id;
  END IF;
  
  -- Return updated config
  v_result := xdelo_get_product_matching_config();
  RETURN v_result;
END;
$function$
","jsonb","p_config jsonb"
"xdelo_validate_media_group_sync","CREATE OR REPLACE FUNCTION public.xdelo_validate_media_group_sync()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- If this is a media group message with analyzed content
    IF NEW.media_group_id IS NOT NULL AND NEW.analyzed_content IS NOT NULL THEN
        -- Mark as original caption holder if not already set
        NEW.is_original_caption := COALESCE(NEW.is_original_caption, true);
        
        -- Ensure we have a correlation ID for logging
        IF NEW.correlation_id IS NULL THEN
            NEW.correlation_id := gen_random_uuid();
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
","trigger",""
"xdelo_validate_message_ids","CREATE OR REPLACE FUNCTION public.xdelo_validate_message_ids(p_message_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_exists boolean;
BEGIN
  SELECT EXISTS(SELECT 1 FROM public.messages WHERE id = p_message_id) INTO v_exists;
  RETURN v_exists;
END;
$function$
","boolean","p_message_id uuid"