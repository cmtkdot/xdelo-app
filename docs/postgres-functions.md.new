# PostgreSQL Database Functions Documentation

These database functions handle the core operations for the Telegram message processing flow, particularly for message captions and media group synchronization. Each function is documented with its purpose, parameters, return values, and usage examples.

## Table of Contents
1. [upsert_media_message](#upsert_media_message)
2. [update_message_analyzed_content](#update_message_analyzed_content)
3. [xdelo_sync_media_group](#xdelo_sync_media_group)
4. [upsert_text_message](#upsert_text_message)
5. [update_message_edit_history](#update_message_edit_history)
6. [align_caption_and_analyzed_content](#align_caption_and_analyzed_content)
7. [sync_caption_fields_trigger](#sync_caption_fields_trigger)
8. [sync_media_group_captions](#sync_media_group_captions)
9. [trigger_sync_media_group_captions](#trigger_sync_media_group_captions)
10. [prevent_unnecessary_message_updates](#prevent_unnecessary_message_updates)
11. [should_sync_media_group](#should_sync_media_group)

---

## upsert_media_message

```typescript
/**
 * Upserts a media message record in the database
 * 
 * This function creates or updates a media message record in the 'messages' table.
 * It handles various types of media including photos, videos, documents, etc.
 * 
 * @param {BIGINT} p_telegram_message_id - Telegram message ID
 * @param {BIGINT} p_chat_id - Telegram chat ID
 * @param {TEXT} p_telegram_file_id - Telegram file ID for the media
 * @param {TEXT} p_telegram_file_unique_id - Unique file ID from Telegram
 * @param {TEXT} p_media_type - Type of media (photo, video, document, etc.)
 * @param {TEXT} p_caption - Media caption text (optional)
 * @param {JSONB} p_message_data - Complete Telegram message data
 * @param {TEXT} p_mime_type - MIME type of the media (optional)
 * @param {public.telegram_chat_type} p_chat_type - Type of chat (private, group, etc.) (optional)
 * @param {TEXT} p_chat_title - Title of the chat (optional)
 * @param {TEXT} p_file_extension - File extension (optional)
 * @param {TEXT} p_media_group_id - Media group ID for grouped messages (optional)
 * @param {JSONB} p_forward_info - Forwarded message information (optional)
 * @param {UUID} p_uploader_user_id - ID of the user who uploaded the file (optional)
 * @param {public.processing_state_type} p_processing_state - Processing state (optional, default: 'initialized')
 * @returns {UUID} - The ID of the created or updated message record
 * 
 * @example
 * SELECT * FROM public.upsert_media_message(
 *   123456789, -- telegram_message_id
 *   987654321, -- chat_id
 *   'file_id_from_telegram', -- telegram_file_id
 *   'unique_file_id', -- telegram_file_unique_id
 *   'photo', -- media_type
 *   'Photo caption', -- caption
 *   '{"message_id": 123456789, "chat": {"id": 987654321}}', -- message_data
 *   'image/jpeg', -- mime_type
 *   'private', -- chat_type
 *   'Chat title', -- chat_title
 *   'jpg', -- file_extension
 *   'media_group_123', -- media_group_id
 *   '{"from_chat_id": 123, "date": "2023-01-01"}', -- forward_info
 *   NULL, -- uploader_user_id
 *   'initialized' -- processing_state
 * );
 */
```

## update_message_analyzed_content

```typescript
/**
 * Updates the analyzed content for a message
 * 
 * This function updates the analyzed_content field for a message, archiving
 * the previous content to old_analyzed_content when appropriate.
 * 
 * @param {UUID} p_message_id - ID of the message to update
 * @param {JSONB} p_analyzed_content - New analyzed content data
 * @param {public.processing_state_type} p_processing_state - New processing state (optional)
 * @returns {UUID} - The ID of the updated message
 * 
 * @example
 * SELECT * FROM public.update_message_analyzed_content(
 *   'a1b2c3d4-e5f6-...',
 *   '{"parsed": {"entities": [{"type": "mention", "text": "@username"}]}}',
 *   'processed'
 * );
 */
```

## xdelo_sync_media_group

```typescript
/**
 * Synchronizes caption and analyzed content across a media group
 * 
 * This function ensures all messages in a media group share the same caption,
 * caption_data, and relevant metadata. It copies values from a source message
 * to all other messages in the group.
 * 
 * @param {TEXT} p_media_group_id - Media group ID to synchronize
 * @param {UUID} p_source_message_id - Source message ID to copy data from
 * @param {BOOLEAN} p_is_api_triggered - Whether this was triggered via API
 * @returns {INTEGER} - Number of messages updated
 * 
 * @example
 * SELECT * FROM public.xdelo_sync_media_group(
 *   'media_group_123',
 *   'a1b2c3d4-e5f6-...',
 *   true
 * );
 */
```

## upsert_text_message

```typescript
/**
 * Upserts a text message record in the 'other_messages' table
 * 
 * This function creates or updates a text message record, handling various
 * message attributes and forward information.
 * 
 * @param {BIGINT} p_telegram_message_id - Telegram message ID
 * @param {BIGINT} p_chat_id - Telegram chat ID
 * @param {TEXT} p_message_text - Content of the text message
 * @param {JSONB} p_message_data - Complete Telegram message data
 * @param {TEXT} p_correlation_id - Correlation ID for request tracking
 * @param {TEXT} p_chat_type - Type of chat (optional)
 * @param {TEXT} p_chat_title - Title of the chat (optional)
 * @param {JSONB} p_forward_info - Forwarded message information (optional)
 * @param {TEXT} p_processing_state - Current processing state (optional, default: 'pending_analysis')
 * @param {TEXT} p_processing_error - Error message if processing failed (optional)
 * @returns {UUID} - The ID of the created or updated message record
 * 
 * @example
 * SELECT * FROM public.upsert_text_message(
 *   123456789, -- telegram_message_id
 *   987654321, -- chat_id
 *   'Hello, world!', -- message_text
 *   '{"message_id": 123456789, "chat": {"id": 987654321}}', -- message_data
 *   'corr-123', -- correlation_id
 *   'private', -- chat_type
 *   'Chat Title', -- chat_title
 *   '{"from_chat_id": 123, "date": "2023-01-01"}', -- forward_info
 *   'pending_analysis', -- processing_state
 *   NULL -- processing_error
 * );
 */
```

## update_message_edit_history

```typescript
/**
 * Updates message edit history and handles content changes
 * 
 * This function manages the edit history for messages, including:
 * 1. Archiving previous message content
 * 2. Updating the message with new content
 * 3. Marking the message as edited
 * 4. Updating edit history timestamps
 * 
 * @param {UUID} p_message_id - ID of the message to update
 * @param {TEXT} p_caption - New caption text
 * @param {TEXT} p_message_text - New message text (for text messages)
 * @param {JSONB} p_message_data - Updated Telegram message data
 * @param {public.processing_state_type} p_processing_state - New processing state
 * @returns {UUID} - The ID of the updated message
 * 
 * @example
 * -- For a media message with caption:
 * SELECT * FROM public.update_message_edit_history(
 *   'a1b2c3d4-e5f6-...',
 *   'Updated caption',
 *   NULL,
 *   '{"message_id": 123456789, "edit_date": 1609459200}',
 *   'pending_analysis'
 * );
 * 
 * -- For a text message:
 * SELECT * FROM public.update_message_edit_history(
 *   'a1b2c3d4-e5f6-...',
 *   NULL,
 *   'Updated text content',
 *   '{"message_id": 123456789, "edit_date": 1609459200}',
 *   'pending_analysis'
 * );
 */
```

## align_caption_and_analyzed_content

```typescript
/**
 * Ensures caption_data and analyzed_content fields are synchronized
 * 
 * This function checks if both fields exist and copies data between them
 * to ensure they are synchronized when one is updated without the other.
 * 
 * @param {UUID} p_message_id - ID of the message to update
 * @returns {UUID} - The ID of the updated message
 * 
 * @example
 * SELECT * FROM public.align_caption_and_analyzed_content(
 *   'a1b2c3d4-e5f6-...'
 * );
 */
```

## sync_caption_fields_trigger

```typescript
/**
 * Trigger function to maintain caption_data and analyzed_content field synchronization
 * 
 * This trigger function fires BEFORE UPDATE on the messages table and ensures
 * that both caption_data and analyzed_content fields stay synchronized. It handles:
 * 1. When caption_data is updated but analyzed_content is not, it updates analyzed_content
 * 2. When analyzed_content is updated but caption_data is not, it updates caption_data
 * 
 * @trigger BEFORE UPDATE ON public.messages FOR EACH ROW
 * 
 * @param {trigger} - Standard trigger parameters (NEW and OLD row values)
 * @returns {trigger} - Modified NEW row with synchronized fields
 * 
 * @example
 * -- This trigger runs automatically on any update to the messages table
 * -- For instance, when manually updating only one field:
 * 
 * UPDATE messages
 * SET caption_data = '{"parsed": "new data"}'
 * WHERE id = 'some-uuid';
 * 
 * -- The trigger will automatically ensure analyzed_content is also updated
 * -- to maintain field synchronization
 */
```

## sync_media_group_captions

```typescript
/**
 * Synchronizes captions and analyzed content across all messages in a media group
 * 
 * This function updates captions and analyzed content for all messages in the same
 * media group (except for the one that triggered the sync). It also handles archiving
 * previous analyzed content to old_analyzed_content when updates occur.
 * 
 * Key operations performed:
 * 1. Archives existing analyzed_content to old_analyzed_content array
 * 2. Updates caption and analyzed_content fields to match source message
 * 3. Updates processing_state to trigger appropriate workflows
 * 4. Marks messages as edited and updates timestamps
 * 5. Returns UUIDs of all updated messages
 *
 * @param {TEXT} p_media_group_id - Media group ID to synchronize
 * @param {TEXT} p_exclude_message_id - Message ID to exclude from updates
 * @param {TEXT} p_caption - New caption to apply to all group messages
 * @param {JSONB} p_caption_data - New analyzed content data to apply
 * @param {public.processing_state_type} p_processing_state - Processing state to set (defaults to 'pending_analysis')
 * @returns {SETOF UUID} Array of message IDs that were updated
 * 
 * @example
 * -- Sync all related messages with a new caption and analyzed content
 * SELECT * FROM public.sync_media_group_captions(
 *   'media_group_123',
 *   'a1b2c3d4-e5f6-...',
 *   'New shared caption',
 *   '{"parsed": {"tags": ["travel", "nature"]}}',
 *   'pending_analysis'
 * );
 */
```

## trigger_sync_media_group_captions

```typescript
/**
 * Trigger function that automatically synchronizes media group messages
 * 
 * This trigger fires AFTER INSERT or UPDATE on the messages table when
 * analyzed_content or caption changes on a message with a media_group_id.
 * It ensures all messages in the same group have consistent content.
 * 
 * The function implements safeguards to prevent infinite recursion
 * and logs all operations to the audit_logs table with detailed metadata.
 * 
 * Key operations:
 * 1. Detects relevant changes to caption or analyzed_content
 * 2. Calls sync_media_group_captions function with appropriate parameters
 * 3. Records sync operations in audit_logs for monitoring
 * 4. Handles errors gracefully without failing the transaction
 * 
 * @trigger AFTER INSERT OR UPDATE OF analyzed_content, caption ON public.messages
 * @condition NEW.media_group_id IS NOT NULL
 * 
 * @example
 * -- This trigger runs automatically on any relevant update
 * -- For instance, when manually updating a caption:
 * 
 * UPDATE messages
 * SET caption = 'New group caption'
 * WHERE id = 'some-uuid' AND media_group_id IS NOT NULL;
 * 
 * -- The trigger will automatically update all other messages in the group
 * -- and record the operation in audit_logs
 */
```

## prevent_unnecessary_message_updates

```typescript
/**
 * Trigger function to prevent unnecessary update cycles
 * 
 * This trigger fires BEFORE UPDATE on the messages table and checks if
 * any relevant fields have actually changed. If no changes are detected,
 * it prevents the update from proceeding, which helps avoid triggering
 * unnecessary sync operations and infinite loops.
 * 
 * Monitored fields:
 * - caption
 * - analyzed_content
 * - processing_state
 * - is_edited
 * 
 * When none of these fields change, the update is skipped entirely by
 * returning NULL instead of NEW.
 * 
 * @trigger BEFORE UPDATE ON public.messages FOR EACH ROW
 * 
 * @example
 * -- This trigger runs automatically on any update
 * -- If no relevant fields changed, the update is skipped entirely
 * 
 * UPDATE messages 
 * SET updated_at = now()
 * WHERE id = 'some-uuid' AND caption IS NOT NULL;
 * 
 * -- If only the updated_at field changed but caption and analyzed_content
 * -- remained the same, the update would be blocked to prevent unnecessary
 * -- synchronization operations
 */
```

## should_sync_media_group

```typescript
/**
 * Helper function to determine if media group sync is needed
 * 
 * This function analyzes the old and new record states to determine
 * if synchronization should occur. It checks for media_group_id existence
 * and changes to relevant fields like caption and analyzed_content.
 * 
 * Decision logic:
 * 1. Always returns false if no media_group_id exists
 * 2. For new records, checks if sufficient content exists to sync
 * 3. For updates, compares old and new values of caption and analyzed_content
 * 
 * @param {JSONB} p_old_record - Previous record state as JSONB (NULL for INSERTs)
 * @param {JSONB} p_new_record - New record state as JSONB
 * @returns {BOOLEAN} True if sync should occur, false otherwise
 * 
 * @example
 * -- Check if sync should happen for a record update
 * SELECT public.should_sync_media_group(
 *   '{"media_group_id":"123","caption":"Old caption","analyzed_content":{}}',
 *   '{"media_group_id":"123","caption":"New caption","analyzed_content":{}}'
 * );
 * -- Returns: true (because caption changed)
 * 
 * -- Check with no media group ID
 * SELECT public.should_sync_media_group(
 *   NULL,
 *   '{"caption":"New caption","analyzed_content":{}}'  
 * );
 * -- Returns: false (no media group to sync)
 */
```
